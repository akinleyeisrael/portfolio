/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/easymde";
exports.ids = ["vendor-chunks/easymde"];
exports.modules = {

/***/ "(ssr)/./node_modules/easymde/src/js/codemirror/tablist.js":
/*!***********************************************************!*\
  !*** ./node_modules/easymde/src/js/codemirror/tablist.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\nvar CodeMirror = __webpack_require__(/*! codemirror */ \"(ssr)/./node_modules/codemirror/lib/codemirror.js\");\n\nCodeMirror.commands.tabAndIndentMarkdownList = function (cm) {\n    var ranges = cm.listSelections();\n    var pos = ranges[0].head;\n    var eolState = cm.getStateAfter(pos.line);\n    var inList = eolState.list !== false;\n\n    if (inList) {\n        cm.execCommand('indentMore');\n        return;\n    }\n\n    if (cm.options.indentWithTabs) {\n        cm.execCommand('insertTab');\n    } else {\n        var spaces = Array(cm.options.tabSize + 1).join(' ');\n        cm.replaceSelection(spaces);\n    }\n};\n\nCodeMirror.commands.shiftTabAndUnindentMarkdownList = function (cm) {\n    var ranges = cm.listSelections();\n    var pos = ranges[0].head;\n    var eolState = cm.getStateAfter(pos.line);\n    var inList = eolState.list !== false;\n\n    if (inList) {\n        cm.execCommand('indentLess');\n        return;\n    }\n\n    if (cm.options.indentWithTabs) {\n        cm.execCommand('insertTab');\n    } else {\n        var spaces = Array(cm.options.tabSize + 1).join(' ');\n        cm.replaceSelection(spaces);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9zcmMvanMvY29kZW1pcnJvci90YWJsaXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMscUVBQVk7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9lYXN5bWRlL3NyYy9qcy9jb2RlbWlycm9yL3RhYmxpc3QuanM/ZGJmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHA6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbnZhciBDb2RlTWlycm9yID0gcmVxdWlyZSgnY29kZW1pcnJvcicpO1xuXG5Db2RlTWlycm9yLmNvbW1hbmRzLnRhYkFuZEluZGVudE1hcmtkb3duTGlzdCA9IGZ1bmN0aW9uIChjbSkge1xuICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgIHZhciBwb3MgPSByYW5nZXNbMF0uaGVhZDtcbiAgICB2YXIgZW9sU3RhdGUgPSBjbS5nZXRTdGF0ZUFmdGVyKHBvcy5saW5lKTtcbiAgICB2YXIgaW5MaXN0ID0gZW9sU3RhdGUubGlzdCAhPT0gZmFsc2U7XG5cbiAgICBpZiAoaW5MaXN0KSB7XG4gICAgICAgIGNtLmV4ZWNDb21tYW5kKCdpbmRlbnRNb3JlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY20ub3B0aW9ucy5pbmRlbnRXaXRoVGFicykge1xuICAgICAgICBjbS5leGVjQ29tbWFuZCgnaW5zZXJ0VGFiJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNwYWNlcyA9IEFycmF5KGNtLm9wdGlvbnMudGFiU2l6ZSArIDEpLmpvaW4oJyAnKTtcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihzcGFjZXMpO1xuICAgIH1cbn07XG5cbkNvZGVNaXJyb3IuY29tbWFuZHMuc2hpZnRUYWJBbmRVbmluZGVudE1hcmtkb3duTGlzdCA9IGZ1bmN0aW9uIChjbSkge1xuICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgIHZhciBwb3MgPSByYW5nZXNbMF0uaGVhZDtcbiAgICB2YXIgZW9sU3RhdGUgPSBjbS5nZXRTdGF0ZUFmdGVyKHBvcy5saW5lKTtcbiAgICB2YXIgaW5MaXN0ID0gZW9sU3RhdGUubGlzdCAhPT0gZmFsc2U7XG5cbiAgICBpZiAoaW5MaXN0KSB7XG4gICAgICAgIGNtLmV4ZWNDb21tYW5kKCdpbmRlbnRMZXNzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY20ub3B0aW9ucy5pbmRlbnRXaXRoVGFicykge1xuICAgICAgICBjbS5leGVjQ29tbWFuZCgnaW5zZXJ0VGFiJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNwYWNlcyA9IEFycmF5KGNtLm9wdGlvbnMudGFiU2l6ZSArIDEpLmpvaW4oJyAnKTtcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihzcGFjZXMpO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/easymde/src/js/codemirror/tablist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/easymde/src/js/easymde.js":
/*!************************************************!*\
  !*** ./node_modules/easymde/src/js/easymde.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar CodeMirror = __webpack_require__(/*! codemirror */ \"(ssr)/./node_modules/codemirror/lib/codemirror.js\");\n__webpack_require__(/*! codemirror/addon/edit/continuelist.js */ \"(ssr)/./node_modules/codemirror/addon/edit/continuelist.js\");\n__webpack_require__(/*! ./codemirror/tablist */ \"(ssr)/./node_modules/easymde/src/js/codemirror/tablist.js\");\n__webpack_require__(/*! codemirror/addon/display/fullscreen.js */ \"(ssr)/./node_modules/codemirror/addon/display/fullscreen.js\");\n__webpack_require__(/*! codemirror/mode/markdown/markdown.js */ \"(ssr)/./node_modules/codemirror/mode/markdown/markdown.js\");\n__webpack_require__(/*! codemirror/addon/mode/overlay.js */ \"(ssr)/./node_modules/codemirror/addon/mode/overlay.js\");\n__webpack_require__(/*! codemirror/addon/display/placeholder.js */ \"(ssr)/./node_modules/codemirror/addon/display/placeholder.js\");\n__webpack_require__(/*! codemirror/addon/display/autorefresh.js */ \"(ssr)/./node_modules/codemirror/addon/display/autorefresh.js\");\n__webpack_require__(/*! codemirror/addon/selection/mark-selection.js */ \"(ssr)/./node_modules/codemirror/addon/selection/mark-selection.js\");\n__webpack_require__(/*! codemirror/addon/search/searchcursor.js */ \"(ssr)/./node_modules/codemirror/addon/search/searchcursor.js\");\n__webpack_require__(/*! codemirror/mode/gfm/gfm.js */ \"(ssr)/./node_modules/codemirror/mode/gfm/gfm.js\");\n__webpack_require__(/*! codemirror/mode/xml/xml.js */ \"(ssr)/./node_modules/codemirror/mode/xml/xml.js\");\nvar CodeMirrorSpellChecker = __webpack_require__(/*! codemirror-spell-checker */ \"(ssr)/./node_modules/codemirror-spell-checker/src/js/spell-checker.js\");\nvar marked = (__webpack_require__(/*! marked */ \"(ssr)/./node_modules/marked/lib/marked.cjs\").marked);\n\n\n// Some variables\nvar isMac = /Mac/.test(navigator.platform);\nvar anchorToExternalRegex = new RegExp(/(<a.*?https?:\\/\\/.*?[^a]>)+?/g);\n\n// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons\nvar bindings = {\n    'toggleBold': toggleBold,\n    'toggleItalic': toggleItalic,\n    'drawLink': drawLink,\n    'toggleHeadingSmaller': toggleHeadingSmaller,\n    'toggleHeadingBigger': toggleHeadingBigger,\n    'drawImage': drawImage,\n    'toggleBlockquote': toggleBlockquote,\n    'toggleOrderedList': toggleOrderedList,\n    'toggleUnorderedList': toggleUnorderedList,\n    'toggleCodeBlock': toggleCodeBlock,\n    'togglePreview': togglePreview,\n    'toggleStrikethrough': toggleStrikethrough,\n    'toggleHeading1': toggleHeading1,\n    'toggleHeading2': toggleHeading2,\n    'toggleHeading3': toggleHeading3,\n    'toggleHeading4': toggleHeading4,\n    'toggleHeading5': toggleHeading5,\n    'toggleHeading6': toggleHeading6,\n    'cleanBlock': cleanBlock,\n    'drawTable': drawTable,\n    'drawHorizontalRule': drawHorizontalRule,\n    'undo': undo,\n    'redo': redo,\n    'toggleSideBySide': toggleSideBySide,\n    'toggleFullScreen': toggleFullScreen,\n};\n\nvar shortcuts = {\n    'toggleBold': 'Cmd-B',\n    'toggleItalic': 'Cmd-I',\n    'drawLink': 'Cmd-K',\n    'toggleHeadingSmaller': 'Cmd-H',\n    'toggleHeadingBigger': 'Shift-Cmd-H',\n    'toggleHeading1': 'Ctrl+Alt+1',\n    'toggleHeading2': 'Ctrl+Alt+2',\n    'toggleHeading3': 'Ctrl+Alt+3',\n    'toggleHeading4': 'Ctrl+Alt+4',\n    'toggleHeading5': 'Ctrl+Alt+5',\n    'toggleHeading6': 'Ctrl+Alt+6',\n    'cleanBlock': 'Cmd-E',\n    'drawImage': 'Cmd-Alt-I',\n    'toggleBlockquote': 'Cmd-\\'',\n    'toggleOrderedList': 'Cmd-Alt-L',\n    'toggleUnorderedList': 'Cmd-L',\n    'toggleCodeBlock': 'Cmd-Alt-C',\n    'togglePreview': 'Cmd-P',\n    'toggleSideBySide': 'F9',\n    'toggleFullScreen': 'F11',\n};\n\nvar getBindingName = function (f) {\n    for (var key in bindings) {\n        if (bindings[key] === f) {\n            return key;\n        }\n    }\n    return null;\n};\n\nvar isMobile = function () {\n    var check = false;\n    (function (a) {\n        if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(a.substr(0, 4))) check = true;\n    })(navigator.userAgent || navigator.vendor || window.opera);\n    return check;\n};\n\n/**\n * Modify HTML to add 'target=\"_blank\"' to links so they open in new tabs by default.\n * @param {string} htmlText - HTML to be modified.\n * @return {string} The modified HTML text.\n */\nfunction addAnchorTargetBlank(htmlText) {\n    var match;\n    while ((match = anchorToExternalRegex.exec(htmlText)) !== null) {\n        // With only one capture group in the RegExp, we can safely take the first index from the match.\n        var linkString = match[0];\n\n        if (linkString.indexOf('target=') === -1) {\n            var fixedLinkString = linkString.replace(/>$/, ' target=\"_blank\">');\n            htmlText = htmlText.replace(linkString, fixedLinkString);\n        }\n    }\n    return htmlText;\n}\n\n/**\n * Modify HTML to remove the list-style when rendering checkboxes.\n * @param {string} htmlText - HTML to be modified.\n * @return {string} The modified HTML text.\n */\nfunction removeListStyleWhenCheckbox(htmlText) {\n\n    var parser = new DOMParser();\n    var htmlDoc = parser.parseFromString(htmlText, 'text/html');\n    var listItems = htmlDoc.getElementsByTagName('li');\n\n    for (var i = 0; i < listItems.length; i++) {\n        var listItem = listItems[i];\n\n        for (var j = 0; j < listItem.children.length; j++) {\n            var listItemChild = listItem.children[j];\n\n            if (listItemChild instanceof HTMLInputElement && listItemChild.type === 'checkbox') {\n                // From Github: margin: 0 .2em .25em -1.6em;\n                listItem.style.marginLeft = '-1.5em';\n                listItem.style.listStyleType = 'none';\n            }\n        }\n    }\n\n    return htmlDoc.documentElement.innerHTML;\n}\n\n/**\n * Fix shortcut. Mac use Command, others use Ctrl.\n */\nfunction fixShortcut(name) {\n    if (isMac) {\n        name = name.replace('Ctrl', 'Cmd');\n    } else {\n        name = name.replace('Cmd', 'Ctrl');\n    }\n    return name;\n}\n\n/**\n * Create dropdown block\n */\nfunction createToolbarDropdown(options, enableTooltips, shortcuts, parent) {\n    var el = createToolbarButton(options, false, enableTooltips, shortcuts, 'button', parent);\n    el.classList.add('easymde-dropdown');\n\n    el.onclick = function () {\n        el.focus();\n    };\n\n    var content = document.createElement('div');\n    content.className = 'easymde-dropdown-content';\n    for (var childrenIndex = 0; childrenIndex < options.children.length; childrenIndex++) {\n\n        var child = options.children[childrenIndex];\n        var childElement;\n\n        if (typeof child === 'string' && child in toolbarBuiltInButtons) {\n            childElement = createToolbarButton(toolbarBuiltInButtons[child], true, enableTooltips, shortcuts, 'button', parent);\n        } else {\n            childElement = createToolbarButton(child, true, enableTooltips, shortcuts, 'button', parent);\n        }\n\n        childElement.addEventListener('click', function (e) { e.stopPropagation(); }, false);\n        content.appendChild(childElement);\n    }\n    el.appendChild(content);\n    return el;\n}\n\n/**\n * Create button element for toolbar.\n */\nfunction createToolbarButton(options, enableActions, enableTooltips, shortcuts, markup, parent) {\n    options = options || {};\n    var el = document.createElement(markup);\n\n    // Add 'custom' attributes as early as possible, so that 'official' attributes will never be overwritten.\n    if (options.attributes) {\n        for (var attribute in options.attributes) {\n            if (Object.prototype.hasOwnProperty.call(options.attributes, attribute)) {\n                el.setAttribute(attribute, options.attributes[attribute]);\n            }\n        }\n    }\n\n    var classNamePrefix = parent.options.toolbarButtonClassPrefix ? parent.options.toolbarButtonClassPrefix + '-' : '';\n    el.className = classNamePrefix + options.name;\n    el.setAttribute('type', markup);\n    enableTooltips = (enableTooltips == undefined) ? true : enableTooltips;\n\n    if (options.text) {\n        el.innerText = options.text;\n    }\n\n    // Properly handle custom shortcuts\n    if (options.name && options.name in shortcuts) {\n        bindings[options.name] = options.action;\n    }\n\n    if (options.title && enableTooltips) {\n        el.title = createTooltip(options.title, options.action, shortcuts);\n\n        if (isMac) {\n            el.title = el.title.replace('Ctrl', '⌘');\n            el.title = el.title.replace('Alt', '⌥');\n        }\n    }\n\n    if (options.title) {\n        el.setAttribute('aria-label', options.title);\n    }\n\n    if (options.noDisable) {\n        el.classList.add('no-disable');\n    }\n\n    if (options.noMobile) {\n        el.classList.add('no-mobile');\n    }\n\n    // Prevent errors if there is no class name in custom options\n    var classNameParts = [];\n    if (typeof options.className !== 'undefined') {\n        classNameParts = options.className.split(' ');\n    }\n\n    // Provide backwards compatibility with simple-markdown-editor by adding custom classes to the button.\n    var iconClasses = [];\n    for (var classNameIndex = 0; classNameIndex < classNameParts.length; classNameIndex++) {\n        var classNamePart = classNameParts[classNameIndex];\n        // Split icon classes from the button.\n        // Regex will detect \"fa\", \"fas\", \"fa-something\" and \"fa-some-icon-1\", but not \"fanfare\".\n        if (classNamePart.match(/^fa([srlb]|(-[\\w-]*)|$)/)) {\n            iconClasses.push(classNamePart);\n        } else {\n            el.classList.add(classNamePart);\n        }\n    }\n\n    el.tabIndex = -1;\n\n    if (iconClasses.length > 0) {\n        // Create icon element and append as a child to the button\n        var icon = document.createElement('i');\n        for (var iconClassIndex = 0; iconClassIndex < iconClasses.length; iconClassIndex++) {\n            var iconClass = iconClasses[iconClassIndex];\n            icon.classList.add(iconClass);\n        }\n        el.appendChild(icon);\n    }\n\n    // If there is a custom icon markup set, use that\n    if (typeof options.icon !== 'undefined') {\n        el.innerHTML = options.icon;\n    }\n\n    if (options.action && enableActions) {\n        if (typeof options.action === 'function') {\n            el.onclick = function (e) {\n                e.preventDefault();\n                options.action(parent);\n            };\n        } else if (typeof options.action === 'string') {\n            el.onclick = function (e) {\n                e.preventDefault();\n                window.open(options.action, '_blank');\n            };\n        }\n    }\n\n    return el;\n}\n\nfunction createSep() {\n    var el = document.createElement('i');\n    el.className = 'separator';\n    el.innerHTML = '|';\n    return el;\n}\n\nfunction createTooltip(title, action, shortcuts) {\n    var actionName;\n    var tooltip = title;\n\n    if (action) {\n        actionName = getBindingName(action);\n        if (shortcuts[actionName]) {\n            tooltip += ' (' + fixShortcut(shortcuts[actionName]) + ')';\n        }\n    }\n\n    return tooltip;\n}\n\n/**\n * The state of CodeMirror at the given position.\n */\nfunction getState(cm, pos) {\n    pos = pos || cm.getCursor('start');\n    var stat = cm.getTokenAt(pos);\n    if (!stat.type) return {};\n\n    var types = stat.type.split(' ');\n\n    var ret = {},\n        data, text;\n    for (var i = 0; i < types.length; i++) {\n        data = types[i];\n        if (data === 'strong') {\n            ret.bold = true;\n        } else if (data === 'variable-2') {\n            text = cm.getLine(pos.line);\n            if (/^\\s*\\d+\\.\\s/.test(text)) {\n                ret['ordered-list'] = true;\n            } else {\n                ret['unordered-list'] = true;\n            }\n        } else if (data === 'atom') {\n            ret.quote = true;\n        } else if (data === 'em') {\n            ret.italic = true;\n        } else if (data === 'quote') {\n            ret.quote = true;\n        } else if (data === 'strikethrough') {\n            ret.strikethrough = true;\n        } else if (data === 'comment') {\n            ret.code = true;\n        } else if (data === 'link' && !ret.image) {\n            ret.link = true;\n        } else if (data === 'image') {\n            ret.image = true;\n        } else if (data.match(/^header(-[1-6])?$/)) {\n            ret[data.replace('header', 'heading')] = true;\n        }\n    }\n    return ret;\n}\n\n\n// Saved overflow setting\nvar saved_overflow = '';\n\n/**\n * Toggle full screen of the editor.\n * @param {EasyMDE} editor\n */\nfunction toggleFullScreen(editor) {\n    // Set fullscreen\n    var cm = editor.codemirror;\n    cm.setOption('fullScreen', !cm.getOption('fullScreen'));\n\n\n    // Prevent scrolling on body during fullscreen active\n    if (cm.getOption('fullScreen')) {\n        saved_overflow = document.body.style.overflow;\n        document.body.style.overflow = 'hidden';\n    } else {\n        document.body.style.overflow = saved_overflow;\n    }\n\n    var wrapper = cm.getWrapperElement();\n    var sidebyside = wrapper.nextSibling;\n\n    if (sidebyside.classList.contains('editor-preview-active-side')) {\n        if (editor.options.sideBySideFullscreen === false) {\n            // if side-by-side not-fullscreen ok, apply classes as needed\n            var easyMDEContainer = wrapper.parentNode;\n            if (cm.getOption('fullScreen')) {\n                easyMDEContainer.classList.remove('sided--no-fullscreen');\n            } else {\n                easyMDEContainer.classList.add('sided--no-fullscreen');\n            }\n        } else {\n            toggleSideBySide(editor);\n        }\n    }\n\n    if (editor.options.onToggleFullScreen) {\n        editor.options.onToggleFullScreen(cm.getOption('fullScreen') || false);\n    }\n\n    // Remove or set maxHeight\n    if (typeof editor.options.maxHeight !== 'undefined') {\n        if (cm.getOption('fullScreen')) {\n            cm.getScrollerElement().style.removeProperty('height');\n            sidebyside.style.removeProperty('height');\n        } else {\n            cm.getScrollerElement().style.height = editor.options.maxHeight;\n            editor.setPreviewMaxHeight();\n        }\n    }\n\n    // Update toolbar class\n    editor.toolbar_div.classList.toggle('fullscreen');\n\n    // Update toolbar button\n    if (editor.toolbarElements && editor.toolbarElements.fullscreen) {\n        var toolbarButton = editor.toolbarElements.fullscreen;\n        toolbarButton.classList.toggle('active');\n    }\n}\n\n\n/**\n * Action for toggling bold.\n * @param {EasyMDE} editor\n */\nfunction toggleBold(editor) {\n    _toggleBlock(editor, 'bold', editor.options.blockStyles.bold);\n}\n\n\n/**\n * Action for toggling italic.\n * @param {EasyMDE} editor\n */\nfunction toggleItalic(editor) {\n    _toggleBlock(editor, 'italic', editor.options.blockStyles.italic);\n}\n\n\n/**\n * Action for toggling strikethrough.\n * @param {EasyMDE} editor\n */\nfunction toggleStrikethrough(editor) {\n    _toggleBlock(editor, 'strikethrough', '~~');\n}\n\n/**\n * Action for toggling code block.\n * @param {EasyMDE} editor\n */\nfunction toggleCodeBlock(editor) {\n    var fenceCharsToInsert = editor.options.blockStyles.code;\n\n    function fencing_line(line) {\n        /* return true, if this is a ``` or ~~~ line */\n        if (typeof line !== 'object') {\n            throw 'fencing_line() takes a \\'line\\' object (not a line number, or line text).  Got: ' + typeof line + ': ' + line;\n        }\n        return line.styles && line.styles[2] && line.styles[2].indexOf('formatting-code-block') !== -1;\n    }\n\n    function token_state(token) {\n        // base goes an extra level deep when mode backdrops are used, e.g. spellchecker on\n        return token.state.base.base || token.state.base;\n    }\n\n    function code_type(cm, line_num, line, firstTok, lastTok) {\n        /*\n         * Return \"single\", \"indented\", \"fenced\" or false\n         *\n         * cm and line_num are required.  Others are optional for efficiency\n         *   To check in the middle of a line, pass in firstTok yourself.\n         */\n        line = line || cm.getLineHandle(line_num);\n        firstTok = firstTok || cm.getTokenAt({\n            line: line_num,\n            ch: 1,\n        });\n        lastTok = lastTok || (!!line.text && cm.getTokenAt({\n            line: line_num,\n            ch: line.text.length - 1,\n        }));\n        var types = firstTok.type ? firstTok.type.split(' ') : [];\n        if (lastTok && token_state(lastTok).indentedCode) {\n            // have to check last char, since first chars of first line aren\"t marked as indented\n            return 'indented';\n        } else if (types.indexOf('comment') === -1) {\n            // has to be after \"indented\" check, since first chars of first indented line aren\"t marked as such\n            return false;\n        } else if (token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {\n            return 'fenced';\n        } else {\n            return 'single';\n        }\n    }\n\n    function insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {\n        var start_line_sel = cur_start.line + 1,\n            end_line_sel = cur_end.line + 1,\n            sel_multi = cur_start.line !== cur_end.line,\n            repl_start = fenceCharsToInsert + '\\n',\n            repl_end = '\\n' + fenceCharsToInsert;\n        if (sel_multi) {\n            end_line_sel++;\n        }\n        // handle last char including \\n or not\n        if (sel_multi && cur_end.ch === 0) {\n            repl_end = fenceCharsToInsert + '\\n';\n            end_line_sel--;\n        }\n        _replaceSelection(cm, false, [repl_start, repl_end]);\n        cm.setSelection({\n            line: start_line_sel,\n            ch: 0,\n        }, {\n            line: end_line_sel,\n            ch: 0,\n        });\n    }\n\n    var cm = editor.codemirror,\n        cur_start = cm.getCursor('start'),\n        cur_end = cm.getCursor('end'),\n        tok = cm.getTokenAt({\n            line: cur_start.line,\n            ch: cur_start.ch || 1,\n        }), // avoid ch 0 which is a cursor pos but not token\n        line = cm.getLineHandle(cur_start.line),\n        is_code = code_type(cm, cur_start.line, line, tok);\n    var block_start, block_end, lineCount;\n\n    if (is_code === 'single') {\n        // similar to some EasyMDE _toggleBlock logic\n        var start = line.text.slice(0, cur_start.ch).replace('`', ''),\n            end = line.text.slice(cur_start.ch).replace('`', '');\n        cm.replaceRange(start + end, {\n            line: cur_start.line,\n            ch: 0,\n        }, {\n            line: cur_start.line,\n            ch: 99999999999999,\n        });\n        cur_start.ch--;\n        if (cur_start !== cur_end) {\n            cur_end.ch--;\n        }\n        cm.setSelection(cur_start, cur_end);\n        cm.focus();\n    } else if (is_code === 'fenced') {\n        if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\n            // use selection\n\n            // find the fenced line so we know what type it is (tilde, backticks, number of them)\n            for (block_start = cur_start.line; block_start >= 0; block_start--) {\n                line = cm.getLineHandle(block_start);\n                if (fencing_line(line)) {\n                    break;\n                }\n            }\n            var fencedTok = cm.getTokenAt({\n                line: block_start,\n                ch: 1,\n            });\n            var fence_chars = token_state(fencedTok).fencedChars;\n            var start_text, start_line;\n            var end_text, end_line;\n            // check for selection going up against fenced lines, in which case we don't want to add more fencing\n            if (fencing_line(cm.getLineHandle(cur_start.line))) {\n                start_text = '';\n                start_line = cur_start.line;\n            } else if (fencing_line(cm.getLineHandle(cur_start.line - 1))) {\n                start_text = '';\n                start_line = cur_start.line - 1;\n            } else {\n                start_text = fence_chars + '\\n';\n                start_line = cur_start.line;\n            }\n            if (fencing_line(cm.getLineHandle(cur_end.line))) {\n                end_text = '';\n                end_line = cur_end.line;\n                if (cur_end.ch === 0) {\n                    end_line += 1;\n                }\n            } else if (cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {\n                end_text = '';\n                end_line = cur_end.line + 1;\n            } else {\n                end_text = fence_chars + '\\n';\n                end_line = cur_end.line + 1;\n            }\n            if (cur_end.ch === 0) {\n                // full last line selected, putting cursor at beginning of next\n                end_line -= 1;\n            }\n            cm.operation(function () {\n                // end line first, so that line numbers don't change\n                cm.replaceRange(end_text, {\n                    line: end_line,\n                    ch: 0,\n                }, {\n                    line: end_line + (end_text ? 0 : 1),\n                    ch: 0,\n                });\n                cm.replaceRange(start_text, {\n                    line: start_line,\n                    ch: 0,\n                }, {\n                    line: start_line + (start_text ? 0 : 1),\n                    ch: 0,\n                });\n            });\n            cm.setSelection({\n                line: start_line + (start_text ? 1 : 0),\n                ch: 0,\n            }, {\n                line: end_line + (start_text ? 1 : -1),\n                ch: 0,\n            });\n            cm.focus();\n        } else {\n            // no selection, search for ends of this fenced block\n            var search_from = cur_start.line;\n            if (fencing_line(cm.getLineHandle(cur_start.line))) { // gets a little tricky if cursor is right on a fenced line\n                if (code_type(cm, cur_start.line + 1) === 'fenced') {\n                    block_start = cur_start.line;\n                    search_from = cur_start.line + 1; // for searching for \"end\"\n                } else {\n                    block_end = cur_start.line;\n                    search_from = cur_start.line - 1; // for searching for \"start\"\n                }\n            }\n            if (block_start === undefined) {\n                for (block_start = search_from; block_start >= 0; block_start--) {\n                    line = cm.getLineHandle(block_start);\n                    if (fencing_line(line)) {\n                        break;\n                    }\n                }\n            }\n            if (block_end === undefined) {\n                lineCount = cm.lineCount();\n                for (block_end = search_from; block_end < lineCount; block_end++) {\n                    line = cm.getLineHandle(block_end);\n                    if (fencing_line(line)) {\n                        break;\n                    }\n                }\n            }\n            cm.operation(function () {\n                cm.replaceRange('', {\n                    line: block_start,\n                    ch: 0,\n                }, {\n                    line: block_start + 1,\n                    ch: 0,\n                });\n                cm.replaceRange('', {\n                    line: block_end - 1,\n                    ch: 0,\n                }, {\n                    line: block_end,\n                    ch: 0,\n                });\n            });\n            cm.focus();\n        }\n    } else if (is_code === 'indented') {\n        if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\n            // use selection\n            block_start = cur_start.line;\n            block_end = cur_end.line;\n            if (cur_end.ch === 0) {\n                block_end--;\n            }\n        } else {\n            // no selection, search for ends of this indented block\n            for (block_start = cur_start.line; block_start >= 0; block_start--) {\n                line = cm.getLineHandle(block_start);\n                if (line.text.match(/^\\s*$/)) {\n                    // empty or all whitespace - keep going\n                    continue;\n                } else {\n                    if (code_type(cm, block_start, line) !== 'indented') {\n                        block_start += 1;\n                        break;\n                    }\n                }\n            }\n            lineCount = cm.lineCount();\n            for (block_end = cur_start.line; block_end < lineCount; block_end++) {\n                line = cm.getLineHandle(block_end);\n                if (line.text.match(/^\\s*$/)) {\n                    // empty or all whitespace - keep going\n                    continue;\n                } else {\n                    if (code_type(cm, block_end, line) !== 'indented') {\n                        block_end -= 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to\n        // insert a blank line so that the next line(s) continue to be indented code\n        var next_line = cm.getLineHandle(block_end + 1),\n            next_line_last_tok = next_line && cm.getTokenAt({\n                line: block_end + 1,\n                ch: next_line.text.length - 1,\n            }),\n            next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;\n        if (next_line_indented) {\n            cm.replaceRange('\\n', {\n                line: block_end + 1,\n                ch: 0,\n            });\n        }\n\n        for (var i = block_start; i <= block_end; i++) {\n            cm.indentLine(i, 'subtract'); // TODO: this doesn't get tracked in the history, so can't be undone :(\n        }\n        cm.focus();\n    } else {\n        // insert code formatting\n        var no_sel_and_starting_of_line = (cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0);\n        var sel_multi = cur_start.line !== cur_end.line;\n        if (no_sel_and_starting_of_line || sel_multi) {\n            insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);\n        } else {\n            _replaceSelection(cm, false, ['`', '`']);\n        }\n    }\n}\n\n/**\n * Action for toggling blockquote.\n */\nfunction toggleBlockquote(editor) {\n    _toggleLine(editor.codemirror, 'quote');\n}\n\n/**\n * Action for toggling heading size: normal -> h1 -> h2 -> h3 -> h4 -> h5 -> h6 -> normal\n */\nfunction toggleHeadingSmaller(editor) {\n    _toggleHeading(editor.codemirror, 'smaller');\n}\n\n/**\n * Action for toggling heading size: normal -> h6 -> h5 -> h4 -> h3 -> h2 -> h1 -> normal\n */\nfunction toggleHeadingBigger(editor) {\n    _toggleHeading(editor.codemirror, 'bigger');\n}\n\n/**\n * Action for toggling heading size 1\n */\nfunction toggleHeading1(editor) {\n    _toggleHeading(editor.codemirror, undefined, 1);\n}\n\n/**\n * Action for toggling heading size 2\n */\nfunction toggleHeading2(editor) {\n    _toggleHeading(editor.codemirror, undefined, 2);\n}\n\n/**\n * Action for toggling heading size 3\n */\nfunction toggleHeading3(editor) {\n    _toggleHeading(editor.codemirror, undefined, 3);\n}\n\n/**\n * Action for toggling heading size 4\n */\nfunction toggleHeading4(editor) {\n    _toggleHeading(editor.codemirror, undefined, 4);\n}\n\n/**\n * Action for toggling heading size 5\n */\nfunction toggleHeading5(editor) {\n    _toggleHeading(editor.codemirror, undefined, 5);\n}\n\n/**\n * Action for toggling heading size 6\n */\nfunction toggleHeading6(editor) {\n    _toggleHeading(editor.codemirror, undefined, 6);\n}\n\n\n/**\n * Action for toggling ul.\n */\nfunction toggleUnorderedList(editor) {\n    var cm = editor.codemirror;\n\n    var listStyle = '*'; // Default\n    if (['-', '+', '*'].includes(editor.options.unorderedListStyle)) {\n        listStyle = editor.options.unorderedListStyle;\n    }\n\n    _toggleLine(cm, 'unordered-list', listStyle);\n}\n\n\n/**\n * Action for toggling ol.\n */\nfunction toggleOrderedList(editor) {\n    _toggleLine(editor.codemirror, 'ordered-list');\n}\n\n/**\n * Action for clean block (remove headline, list, blockquote code, markers)\n */\nfunction cleanBlock(editor) {\n    _cleanBlock(editor.codemirror);\n}\n\n/**\n * Action for drawing a link.\n * @param {EasyMDE} editor\n */\nfunction drawLink(editor) {\n    var options = editor.options;\n    var url = 'https://';\n    if (options.promptURLs) {\n        var result = prompt(options.promptTexts.link, url);\n        if (!result) {\n            return false;\n        }\n        url = escapePromptURL(result);\n    }\n    _toggleLink(editor, 'link', options.insertTexts.link, url);\n}\n\n/**\n * Action for drawing an img.\n * @param {EasyMDE} editor\n */\nfunction drawImage(editor) {\n    var options = editor.options;\n    var url = 'https://';\n    if (options.promptURLs) {\n        var result = prompt(options.promptTexts.image, url);\n        if (!result) {\n            return false;\n        }\n        url = escapePromptURL(result);\n    }\n    _toggleLink(editor, 'image', options.insertTexts.image, url);\n}\n\n/**\n * Encode and escape URLs to prevent breaking up rendered Markdown links.\n * @param {string} url The url of the link or image\n */\nfunction escapePromptURL(url) {\n    return encodeURI(url).replace(/([\\\\()])/g, '\\\\$1');\n}\n\n/**\n * Action for opening the browse-file window to upload an image to a server.\n * @param {EasyMDE} editor The EasyMDE object\n */\nfunction drawUploadedImage(editor) {\n    // TODO: Draw the image template with a fake url? ie: '![](importing foo.png...)'\n    editor.openBrowseFileWindow();\n}\n\n/**\n * Action executed after an image have been successfully imported on the server.\n * @param {EasyMDE} editor The EasyMDE object\n * @param {string} url The url of the uploaded image\n */\nfunction afterImageUploaded(editor, url) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    var imageName = url.substr(url.lastIndexOf('/') + 1);\n    var ext = imageName.substring(imageName.lastIndexOf('.') + 1).replace(/\\?.*$/, '').toLowerCase();\n\n    // Check if media is an image\n    if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'apng', 'avif', 'webp'].includes(ext)) {\n        _replaceSelection(cm, stat.image, options.insertTexts.uploadedImage, url);\n    } else {\n        var text_link = options.insertTexts.link;\n        text_link[0] = '[' + imageName;\n        _replaceSelection(cm, stat.link, text_link, url);\n    }\n\n    // show uploaded image filename for 1000ms\n    editor.updateStatusBar('upload-image', editor.options.imageTexts.sbOnUploaded.replace('#image_name#', imageName));\n    setTimeout(function () {\n        editor.updateStatusBar('upload-image', editor.options.imageTexts.sbInit);\n    }, 1000);\n}\n\n/**\n * Action for drawing a table.\n * @param {EasyMDE} editor\n */\nfunction drawTable(editor) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    _replaceSelection(cm, stat.table, options.insertTexts.table);\n}\n\n/**\n * Action for drawing a horizontal rule.\n * @param {EasyMDE} editor\n */\nfunction drawHorizontalRule(editor) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);\n}\n\n\n/**\n * Undo action.\n * @param {EasyMDE} editor\n */\nfunction undo(editor) {\n    var cm = editor.codemirror;\n    cm.undo();\n    cm.focus();\n}\n\n\n/**\n * Redo action.\n * @param {EasyMDE} editor\n */\nfunction redo(editor) {\n    var cm = editor.codemirror;\n    cm.redo();\n    cm.focus();\n}\n\n\n/**\n * Toggle side by side preview\n * @param {EasyMDE} editor\n */\nfunction toggleSideBySide(editor) {\n    var cm = editor.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n    var toolbarButton = editor.toolbarElements && editor.toolbarElements['side-by-side'];\n    var useSideBySideListener = false;\n\n    var easyMDEContainer = wrapper.parentNode;\n\n    if (preview.classList.contains('editor-preview-active-side')) {\n        if (editor.options.sideBySideFullscreen === false) {\n            // if side-by-side not-fullscreen ok, remove classes when hiding side\n            easyMDEContainer.classList.remove('sided--no-fullscreen');\n        }\n        preview.classList.remove('editor-preview-active-side');\n        if (toolbarButton) toolbarButton.classList.remove('active');\n        wrapper.classList.remove('CodeMirror-sided');\n    } else {\n        // When the preview button is clicked for the first time,\n        // give some time for the transition from editor.css to fire and the view to slide from right to left,\n        // instead of just appearing.\n        setTimeout(function () {\n            if (!cm.getOption('fullScreen')) {\n                if (editor.options.sideBySideFullscreen === false) {\n                    // if side-by-side not-fullscreen ok, add classes when not fullscreen and showing side\n                    easyMDEContainer.classList.add('sided--no-fullscreen');\n                } else {\n                    toggleFullScreen(editor);\n                }\n            }\n            preview.classList.add('editor-preview-active-side');\n        }, 1);\n        if (toolbarButton) toolbarButton.classList.add('active');\n        wrapper.classList.add('CodeMirror-sided');\n        useSideBySideListener = true;\n    }\n\n    // Hide normal preview if active\n    var previewNormal = wrapper.lastChild;\n    if (previewNormal.classList.contains('editor-preview-active')) {\n        previewNormal.classList.remove('editor-preview-active');\n        var toolbar = editor.toolbarElements.preview;\n        var toolbar_div = editor.toolbar_div;\n        toolbar.classList.remove('active');\n        toolbar_div.classList.remove('disabled-for-preview');\n    }\n\n    var sideBySideRenderingFunction = function () {\n        var newValue = editor.options.previewRender(editor.value(), preview);\n        if (newValue != null) {\n            preview.innerHTML = newValue;\n        }\n    };\n\n    if (!cm.sideBySideRenderingFunction) {\n        cm.sideBySideRenderingFunction = sideBySideRenderingFunction;\n    }\n\n    if (useSideBySideListener) {\n        var newValue = editor.options.previewRender(editor.value(), preview);\n        if (newValue != null) {\n            preview.innerHTML = newValue;\n        }\n        cm.on('update', cm.sideBySideRenderingFunction);\n    } else {\n        cm.off('update', cm.sideBySideRenderingFunction);\n    }\n\n    // Refresh to fix selection being off (#309)\n    cm.refresh();\n}\n\n\n/**\n * Preview action.\n * @param {EasyMDE} editor\n */\nfunction togglePreview(editor) {\n    var cm = editor.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var toolbar_div = editor.toolbar_div;\n    var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;\n    var preview = wrapper.lastChild;\n\n    // Turn off side by side if needed\n    var sidebyside = cm.getWrapperElement().nextSibling;\n    if (sidebyside.classList.contains('editor-preview-active-side'))\n        toggleSideBySide(editor);\n\n    if (!preview || !preview.classList.contains('editor-preview-full')) {\n\n        preview = document.createElement('div');\n        preview.className = 'editor-preview-full';\n\n        if (editor.options.previewClass) {\n\n            if (Array.isArray(editor.options.previewClass)) {\n                for (var i = 0; i < editor.options.previewClass.length; i++) {\n                    preview.classList.add(editor.options.previewClass[i]);\n                }\n\n            } else if (typeof editor.options.previewClass === 'string') {\n                preview.classList.add(editor.options.previewClass);\n            }\n        }\n\n        wrapper.appendChild(preview);\n    }\n\n    if (preview.classList.contains('editor-preview-active')) {\n        preview.classList.remove('editor-preview-active');\n        if (toolbar) {\n            toolbar.classList.remove('active');\n            toolbar_div.classList.remove('disabled-for-preview');\n        }\n    } else {\n        // When the preview button is clicked for the first time,\n        // give some time for the transition from editor.css to fire and the view to slide from right to left,\n        // instead of just appearing.\n        setTimeout(function () {\n            preview.classList.add('editor-preview-active');\n        }, 1);\n        if (toolbar) {\n            toolbar.classList.add('active');\n            toolbar_div.classList.add('disabled-for-preview');\n        }\n    }\n\n    var preview_result = editor.options.previewRender(editor.value(), preview);\n    if (preview_result !== null) {\n        preview.innerHTML = preview_result;\n    }\n\n}\n\nfunction _replaceSelection(cm, active, startEnd, url) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var text;\n    var start = startEnd[0];\n    var end = startEnd[1];\n    var startPoint = {},\n        endPoint = {};\n    Object.assign(startPoint, cm.getCursor('start'));\n    Object.assign(endPoint, cm.getCursor('end'));\n    if (url) {\n        start = start.replace('#url#', url);  // url is in start for upload-image\n        end = end.replace('#url#', url);\n    }\n    if (active) {\n        text = cm.getLine(startPoint.line);\n        start = text.slice(0, startPoint.ch);\n        end = text.slice(startPoint.ch);\n        cm.replaceRange(start + end, {\n            line: startPoint.line,\n            ch: 0,\n        });\n    } else {\n        text = cm.getSelection();\n        cm.replaceSelection(start + text + end);\n\n        startPoint.ch += start.length;\n        if (startPoint !== endPoint) {\n            endPoint.ch += start.length;\n        }\n    }\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\n\n\nfunction _toggleHeading(cm, direction, size) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    for (var i = startPoint.line; i <= endPoint.line; i++) {\n        (function (i) {\n            var text = cm.getLine(i);\n            var currHeadingLevel = text.search(/[^#]/);\n\n            if (direction !== undefined) {\n                if (currHeadingLevel <= 0) {\n                    if (direction == 'bigger') {\n                        text = '###### ' + text;\n                    } else {\n                        text = '# ' + text;\n                    }\n                } else if (currHeadingLevel == 6 && direction == 'smaller') {\n                    text = text.substr(7);\n                } else if (currHeadingLevel == 1 && direction == 'bigger') {\n                    text = text.substr(2);\n                } else {\n                    if (direction == 'bigger') {\n                        text = text.substr(1);\n                    } else {\n                        text = '#' + text;\n                    }\n                }\n            } else {\n                if (currHeadingLevel <= 0) {\n                    text = '#'.repeat(size) + ' ' + text;\n                } else if (currHeadingLevel == size) {\n                    text = text.substr(currHeadingLevel + 1);\n                } else {\n                    text = '#'.repeat(size) + ' ' + text.substr(currHeadingLevel + 1);\n                }\n            }\n\n            cm.replaceRange(text, {\n                line: i,\n                ch: 0,\n            }, {\n                line: i,\n                ch: 99999999999999,\n            });\n        })(i);\n    }\n    cm.focus();\n}\n\n\nfunction _toggleLine(cm, name, liststyle) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var listRegexp = /^(\\s*)(\\*|-|\\+|\\d*\\.)(\\s+)/;\n    var whitespacesRegexp = /^\\s*/;\n\n    var stat = getState(cm);\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    var repl = {\n        'quote': /^(\\s*)>\\s+/,\n        'unordered-list': listRegexp,\n        'ordered-list': listRegexp,\n    };\n\n    var _getChar = function (name, i) {\n        var map = {\n            'quote': '>',\n            'unordered-list': liststyle,\n            'ordered-list': '%%i.',\n        };\n\n        return map[name].replace('%%i', i);\n    };\n\n    var _checkChar = function (name, char) {\n        var map = {\n            'quote': '>',\n            'unordered-list': '\\\\' + liststyle,\n            'ordered-list': '\\\\d+.',\n        };\n        var rt = new RegExp(map[name]);\n\n        return char && rt.test(char);\n    };\n\n    var _toggle = function (name, text, untoggleOnly) {\n        var arr = listRegexp.exec(text);\n        var char = _getChar(name, line);\n        if (arr !== null) {\n            if (_checkChar(name, arr[2])) {\n                char = '';\n            }\n            text = arr[1] + char + arr[3] + text.replace(whitespacesRegexp, '').replace(repl[name], '$1');\n        } else if (untoggleOnly == false) {\n            text = char + ' ' + text;\n        }\n        return text;\n    };\n\n    var line = 1;\n    for (var i = startPoint.line; i <= endPoint.line; i++) {\n        (function (i) {\n            var text = cm.getLine(i);\n            if (stat[name]) {\n                text = text.replace(repl[name], '$1');\n            } else {\n                // If we're toggling unordered-list formatting, check if the current line\n                // is part of an ordered-list, and if so, untoggle that first.\n                // Workaround for https://github.com/Ionaru/easy-markdown-editor/issues/92\n                if (name == 'unordered-list') {\n                    text = _toggle('ordered-list', text, true);\n                }\n                text = _toggle(name, text, false);\n                line += 1;\n            }\n            cm.replaceRange(text, {\n                line: i,\n                ch: 0,\n            }, {\n                line: i,\n                ch: 99999999999999,\n            });\n        })(i);\n    }\n    cm.focus();\n}\n\n/**\n * @param {EasyMDE} editor\n * @param {'link' | 'image'} type\n * @param {string} startEnd\n * @param {string} url\n */\nfunction _toggleLink(editor, type, startEnd, url) {\n    if (!editor.codemirror || editor.isPreviewActive()) {\n        return;\n    }\n\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var active = stat[type];\n    if (!active) {\n        _replaceSelection(cm, active, startEnd, url);\n        return;\n    }\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    var text = cm.getLine(startPoint.line);\n    var start = text.slice(0, startPoint.ch);\n    var end = text.slice(startPoint.ch);\n\n    if (type == 'link') {\n        start = start.replace(/(.*)[^!]\\[/, '$1');\n    } else if (type == 'image') {\n        start = start.replace(/(.*)!\\[$/, '$1');\n    }\n    end = end.replace(/]\\(.*?\\)/, '');\n\n    cm.replaceRange(start + end, {\n        line: startPoint.line,\n        ch: 0,\n    }, {\n        line: startPoint.line,\n        ch: 99999999999999,\n    });\n\n    startPoint.ch -= startEnd[0].length;\n    if (startPoint !== endPoint) {\n        endPoint.ch -= startEnd[0].length;\n    }\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\n\n/**\n * @param {EasyMDE} editor\n */\nfunction _toggleBlock(editor, type, start_chars, end_chars) {\n    if (!editor.codemirror || editor.isPreviewActive()) {\n        return;\n    }\n\n    end_chars = (typeof end_chars === 'undefined') ? start_chars : end_chars;\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n\n    var text;\n    var start = start_chars;\n    var end = end_chars;\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n\n    if (stat[type]) {\n        text = cm.getLine(startPoint.line);\n        start = text.slice(0, startPoint.ch);\n        end = text.slice(startPoint.ch);\n        if (type == 'bold') {\n            start = start.replace(/(\\*\\*|__)(?![\\s\\S]*(\\*\\*|__))/, '');\n            end = end.replace(/(\\*\\*|__)/, '');\n        } else if (type == 'italic') {\n            start = start.replace(/(\\*|_)(?![\\s\\S]*(\\*|_))/, '');\n            end = end.replace(/(\\*|_)/, '');\n        } else if (type == 'strikethrough') {\n            start = start.replace(/(\\*\\*|~~)(?![\\s\\S]*(\\*\\*|~~))/, '');\n            end = end.replace(/(\\*\\*|~~)/, '');\n        }\n        cm.replaceRange(start + end, {\n            line: startPoint.line,\n            ch: 0,\n        }, {\n            line: startPoint.line,\n            ch: 99999999999999,\n        });\n\n        if (type == 'bold' || type == 'strikethrough') {\n            startPoint.ch -= 2;\n            if (startPoint !== endPoint) {\n                endPoint.ch -= 2;\n            }\n        } else if (type == 'italic') {\n            startPoint.ch -= 1;\n            if (startPoint !== endPoint) {\n                endPoint.ch -= 1;\n            }\n        }\n    } else {\n        text = cm.getSelection();\n        if (type == 'bold') {\n            text = text.split('**').join('');\n            text = text.split('__').join('');\n        } else if (type == 'italic') {\n            text = text.split('*').join('');\n            text = text.split('_').join('');\n        } else if (type == 'strikethrough') {\n            text = text.split('~~').join('');\n        }\n        cm.replaceSelection(start + text + end);\n\n        startPoint.ch += start_chars.length;\n        endPoint.ch = startPoint.ch + text.length;\n    }\n\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\n\nfunction _cleanBlock(cm) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    var text;\n\n    for (var line = startPoint.line; line <= endPoint.line; line++) {\n        text = cm.getLine(line);\n        text = text.replace(/^[ ]*([# ]+|\\*|-|[> ]+|[0-9]+(.|\\)))[ ]*/, '');\n\n        cm.replaceRange(text, {\n            line: line,\n            ch: 0,\n        }, {\n            line: line,\n            ch: 99999999999999,\n        });\n    }\n}\n\n/**\n * Convert a number of bytes to a human-readable file size. If you desire\n * to add a space between the value and the unit, you need to add this space\n * to the given units.\n * @param bytes {number} A number of bytes, as integer. Ex: 421137\n * @param units {number[]} An array of human-readable units, ie. [' B', ' K', ' MB']\n * @returns string A human-readable file size. Ex: '412 KB'\n */\nfunction humanFileSize(bytes, units) {\n    if (Math.abs(bytes) < 1024) {\n        return '' + bytes + units[0];\n    }\n    var u = 0;\n    do {\n        bytes /= 1024;\n        ++u;\n    } while (Math.abs(bytes) >= 1024 && u < units.length);\n    return '' + bytes.toFixed(1) + units[u];\n}\n\n// Merge the properties of one object into another.\nfunction _mergeProperties(target, source) {\n    for (var property in source) {\n        if (Object.prototype.hasOwnProperty.call(source, property)) {\n            if (source[property] instanceof Array) {\n                target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);\n            } else if (\n                source[property] !== null &&\n                typeof source[property] === 'object' &&\n                source[property].constructor === Object\n            ) {\n                target[property] = _mergeProperties(target[property] || {}, source[property]);\n            } else {\n                target[property] = source[property];\n            }\n        }\n    }\n\n    return target;\n}\n\n// Merge an arbitrary number of objects into one.\nfunction extend(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        target = _mergeProperties(target, arguments[i]);\n    }\n\n    return target;\n}\n\n/* The right word count in respect for CJK. */\nfunction wordCount(data) {\n    var pattern = /[a-zA-Z0-9_\\u00A0-\\u02AF\\u0392-\\u03c9\\u0410-\\u04F9]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af]+/g;\n    var m = data.match(pattern);\n    var count = 0;\n    if (m === null) return count;\n    for (var i = 0; i < m.length; i++) {\n        if (m[i].charCodeAt(0) >= 0x4E00) {\n            count += m[i].length;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nvar iconClassMap = {\n    'bold': 'fa fa-bold',\n    'italic': 'fa fa-italic',\n    'strikethrough': 'fa fa-strikethrough',\n    'heading': 'fa fa-header fa-heading',\n    'heading-smaller': 'fa fa-header fa-heading header-smaller',\n    'heading-bigger': 'fa fa-header fa-heading header-bigger',\n    'heading-1': 'fa fa-header fa-heading header-1',\n    'heading-2': 'fa fa-header fa-heading header-2',\n    'heading-3': 'fa fa-header fa-heading header-3',\n    'code': 'fa fa-code',\n    'quote': 'fa fa-quote-left',\n    'ordered-list': 'fa fa-list-ol',\n    'unordered-list': 'fa fa-list-ul',\n    'clean-block': 'fa fa-eraser',\n    'link': 'fa fa-link',\n    'image': 'fa fa-image',\n    'upload-image': 'fa fa-image',\n    'table': 'fa fa-table',\n    'horizontal-rule': 'fa fa-minus',\n    'preview': 'fa fa-eye',\n    'side-by-side': 'fa fa-columns',\n    'fullscreen': 'fa fa-arrows-alt',\n    'guide': 'fa fa-question-circle',\n    'undo': 'fa fa-undo',\n    'redo': 'fa fa-repeat fa-redo',\n};\n\nvar toolbarBuiltInButtons = {\n    'bold': {\n        name: 'bold',\n        action: toggleBold,\n        className: iconClassMap['bold'],\n        title: 'Bold',\n        default: true,\n    },\n    'italic': {\n        name: 'italic',\n        action: toggleItalic,\n        className: iconClassMap['italic'],\n        title: 'Italic',\n        default: true,\n    },\n    'strikethrough': {\n        name: 'strikethrough',\n        action: toggleStrikethrough,\n        className: iconClassMap['strikethrough'],\n        title: 'Strikethrough',\n    },\n    'heading': {\n        name: 'heading',\n        action: toggleHeadingSmaller,\n        className: iconClassMap['heading'],\n        title: 'Heading',\n        default: true,\n    },\n    'heading-smaller': {\n        name: 'heading-smaller',\n        action: toggleHeadingSmaller,\n        className: iconClassMap['heading-smaller'],\n        title: 'Smaller Heading',\n    },\n    'heading-bigger': {\n        name: 'heading-bigger',\n        action: toggleHeadingBigger,\n        className: iconClassMap['heading-bigger'],\n        title: 'Bigger Heading',\n    },\n    'heading-1': {\n        name: 'heading-1',\n        action: toggleHeading1,\n        className: iconClassMap['heading-1'],\n        title: 'Big Heading',\n    },\n    'heading-2': {\n        name: 'heading-2',\n        action: toggleHeading2,\n        className: iconClassMap['heading-2'],\n        title: 'Medium Heading',\n    },\n    'heading-3': {\n        name: 'heading-3',\n        action: toggleHeading3,\n        className: iconClassMap['heading-3'],\n        title: 'Small Heading',\n    },\n    'separator-1': {\n        name: 'separator-1',\n    },\n    'code': {\n        name: 'code',\n        action: toggleCodeBlock,\n        className: iconClassMap['code'],\n        title: 'Code',\n    },\n    'quote': {\n        name: 'quote',\n        action: toggleBlockquote,\n        className: iconClassMap['quote'],\n        title: 'Quote',\n        default: true,\n    },\n    'unordered-list': {\n        name: 'unordered-list',\n        action: toggleUnorderedList,\n        className: iconClassMap['unordered-list'],\n        title: 'Generic List',\n        default: true,\n    },\n    'ordered-list': {\n        name: 'ordered-list',\n        action: toggleOrderedList,\n        className: iconClassMap['ordered-list'],\n        title: 'Numbered List',\n        default: true,\n    },\n    'clean-block': {\n        name: 'clean-block',\n        action: cleanBlock,\n        className: iconClassMap['clean-block'],\n        title: 'Clean block',\n    },\n    'separator-2': {\n        name: 'separator-2',\n    },\n    'link': {\n        name: 'link',\n        action: drawLink,\n        className: iconClassMap['link'],\n        title: 'Create Link',\n        default: true,\n    },\n    'image': {\n        name: 'image',\n        action: drawImage,\n        className: iconClassMap['image'],\n        title: 'Insert Image',\n        default: true,\n    },\n    'upload-image': {\n        name: 'upload-image',\n        action: drawUploadedImage,\n        className: iconClassMap['upload-image'],\n        title: 'Import an image',\n    },\n    'table': {\n        name: 'table',\n        action: drawTable,\n        className: iconClassMap['table'],\n        title: 'Insert Table',\n    },\n    'horizontal-rule': {\n        name: 'horizontal-rule',\n        action: drawHorizontalRule,\n        className: iconClassMap['horizontal-rule'],\n        title: 'Insert Horizontal Line',\n    },\n    'separator-3': {\n        name: 'separator-3',\n    },\n    'preview': {\n        name: 'preview',\n        action: togglePreview,\n        className: iconClassMap['preview'],\n        noDisable: true,\n        title: 'Toggle Preview',\n        default: true,\n    },\n    'side-by-side': {\n        name: 'side-by-side',\n        action: toggleSideBySide,\n        className: iconClassMap['side-by-side'],\n        noDisable: true,\n        noMobile: true,\n        title: 'Toggle Side by Side',\n        default: true,\n    },\n    'fullscreen': {\n        name: 'fullscreen',\n        action: toggleFullScreen,\n        className: iconClassMap['fullscreen'],\n        noDisable: true,\n        noMobile: true,\n        title: 'Toggle Fullscreen',\n        default: true,\n    },\n    'separator-4': {\n        name: 'separator-4',\n    },\n    'guide': {\n        name: 'guide',\n        action: 'https://www.markdownguide.org/basic-syntax/',\n        className: iconClassMap['guide'],\n        noDisable: true,\n        title: 'Markdown Guide',\n        default: true,\n    },\n    'separator-5': {\n        name: 'separator-5',\n    },\n    'undo': {\n        name: 'undo',\n        action: undo,\n        className: iconClassMap['undo'],\n        noDisable: true,\n        title: 'Undo',\n    },\n    'redo': {\n        name: 'redo',\n        action: redo,\n        className: iconClassMap['redo'],\n        noDisable: true,\n        title: 'Redo',\n    },\n};\n\nvar insertTexts = {\n    link: ['[', '](#url#)'],\n    image: ['![', '](#url#)'],\n    uploadedImage: ['![](#url#)', ''],\n    // uploadedImage: ['![](#url#)\\n', ''], // TODO: New line insertion doesn't work here.\n    table: ['', '\\n\\n| Column 1 | Column 2 | Column 3 |\\n| -------- | -------- | -------- |\\n| Text     | Text     | Text     |\\n\\n'],\n    horizontalRule: ['', '\\n\\n-----\\n\\n'],\n};\n\nvar promptTexts = {\n    link: 'URL for the link:',\n    image: 'URL of the image:',\n};\n\nvar timeFormat = {\n    locale: 'en-US',\n    format: {\n        hour: '2-digit',\n        minute: '2-digit',\n    },\n};\n\nvar blockStyles = {\n    'bold': '**',\n    'code': '```',\n    'italic': '*',\n};\n\n/**\n * Texts displayed to the user (mainly on the status bar) for the import image\n * feature. Can be used for customization or internationalization.\n */\nvar imageTexts = {\n    sbInit: 'Attach files by drag and dropping or pasting from clipboard.',\n    sbOnDragEnter: 'Drop image to upload it.',\n    sbOnDrop: 'Uploading image #images_names#...',\n    sbProgress: 'Uploading #file_name#: #progress#%',\n    sbOnUploaded: 'Uploaded #image_name#',\n    sizeUnits: ' B, KB, MB',\n};\n\n/**\n * Errors displayed to the user, using the `errorCallback` option. Can be used for\n * customization or internationalization.\n */\nvar errorMessages = {\n    noFileGiven: 'You must select a file.',\n    typeNotAllowed: 'This image type is not allowed.',\n    fileTooLarge: 'Image #image_name# is too big (#image_size#).\\n' +\n        'Maximum file size is #image_max_size#.',\n    importError: 'Something went wrong when uploading the image #image_name#.',\n};\n\n/**\n * Interface of EasyMDE.\n */\nfunction EasyMDE(options) {\n    // Handle options parameter\n    options = options || {};\n\n    // Used later to refer to it\"s parent\n    options.parent = this;\n\n    // Check if Font Awesome needs to be auto downloaded\n    var autoDownloadFA = true;\n\n    if (options.autoDownloadFontAwesome === false) {\n        autoDownloadFA = false;\n    }\n\n    if (options.autoDownloadFontAwesome !== true) {\n        var styleSheets = document.styleSheets;\n        for (var i = 0; i < styleSheets.length; i++) {\n            if (!styleSheets[i].href)\n                continue;\n\n            if (styleSheets[i].href.indexOf('//maxcdn.bootstrapcdn.com/font-awesome/') > -1) {\n                autoDownloadFA = false;\n            }\n        }\n    }\n\n    if (autoDownloadFA) {\n        var link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = 'https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css';\n        document.getElementsByTagName('head')[0].appendChild(link);\n    }\n\n\n    // Find the textarea to use\n    if (options.element) {\n        this.element = options.element;\n    } else if (options.element === null) {\n        // This means that the element option was specified, but no element was found\n        console.log('EasyMDE: Error. No element was found.');\n        return;\n    }\n\n\n    // Handle toolbar\n    if (options.toolbar === undefined) {\n        // Initialize\n        options.toolbar = [];\n\n\n        // Loop over the built in buttons, to get the preferred order\n        for (var key in toolbarBuiltInButtons) {\n            if (Object.prototype.hasOwnProperty.call(toolbarBuiltInButtons, key)) {\n                if (key.indexOf('separator-') != -1) {\n                    options.toolbar.push('|');\n                }\n\n                if (toolbarBuiltInButtons[key].default === true || (options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1)) {\n                    options.toolbar.push(key);\n                }\n            }\n        }\n    }\n\n    // Editor preview styling class.\n    if (!Object.prototype.hasOwnProperty.call(options, 'previewClass')) {\n        options.previewClass = 'editor-preview';\n    }\n\n    // Handle status bar\n    if (!Object.prototype.hasOwnProperty.call(options, 'status')) {\n        options.status = ['autosave', 'lines', 'words', 'cursor'];\n\n        if (options.uploadImage) {\n            options.status.unshift('upload-image');\n        }\n    }\n\n\n    // Add default preview rendering function\n    if (!options.previewRender) {\n        options.previewRender = function (plainText) {\n            // Note: \"this\" refers to the options object\n            return this.parent.markdown(plainText);\n        };\n    }\n\n\n    // Set default options for parsing config\n    options.parsingConfig = extend({\n        highlightFormatting: true, // needed for toggleCodeBlock to detect types of code\n    }, options.parsingConfig || {});\n\n\n    // Merging the insertTexts, with the given options\n    options.insertTexts = extend({}, insertTexts, options.insertTexts || {});\n\n\n    // Merging the promptTexts, with the given options\n    options.promptTexts = extend({}, promptTexts, options.promptTexts || {});\n\n\n    // Merging the blockStyles, with the given options\n    options.blockStyles = extend({}, blockStyles, options.blockStyles || {});\n\n\n    if (options.autosave != undefined) {\n        // Merging the Autosave timeFormat, with the given options\n        options.autosave.timeFormat = extend({}, timeFormat, options.autosave.timeFormat || {});\n    }\n\n    options.iconClassMap = extend({}, iconClassMap, options.iconClassMap || {});\n\n    // Merging the shortcuts, with the given options\n    options.shortcuts = extend({}, shortcuts, options.shortcuts || {});\n\n    options.maxHeight = options.maxHeight || undefined;\n\n    options.direction = options.direction || 'ltr';\n\n    if (typeof options.maxHeight !== 'undefined') {\n        // Min and max height are equal if maxHeight is set\n        options.minHeight = options.maxHeight;\n    } else {\n        options.minHeight = options.minHeight || '300px';\n    }\n\n    options.errorCallback = options.errorCallback || function (errorMessage) {\n        alert(errorMessage);\n    };\n\n    // Import-image default configuration\n    options.uploadImage = options.uploadImage || false;\n    options.imageMaxSize = options.imageMaxSize || 2097152; // 1024 * 1024 * 2\n    options.imageAccept = options.imageAccept || 'image/png, image/jpeg, image/gif, image/avif';\n    options.imageTexts = extend({}, imageTexts, options.imageTexts || {});\n    options.errorMessages = extend({}, errorMessages, options.errorMessages || {});\n    options.imagePathAbsolute = options.imagePathAbsolute || false;\n    options.imageCSRFName = options.imageCSRFName || 'csrfmiddlewaretoken';\n    options.imageCSRFHeader = options.imageCSRFHeader || false;\n\n\n    // Change unique_id to uniqueId for backwards compatibility\n    if (options.autosave != undefined && options.autosave.unique_id != undefined && options.autosave.unique_id != '')\n        options.autosave.uniqueId = options.autosave.unique_id;\n\n    // If overlay mode is specified and combine is not provided, default it to true\n    if (options.overlayMode && options.overlayMode.combine === undefined) {\n        options.overlayMode.combine = true;\n    }\n\n    // Update this options\n    this.options = options;\n\n\n    // Auto render\n    this.render();\n\n\n    // The codemirror component is only available after rendering\n    // so, the setter for the initialValue can only run after\n    // the element has been rendered\n    if (options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {\n        this.value(options.initialValue);\n    }\n\n    if (options.uploadImage) {\n        var self = this;\n\n        this.codemirror.on('dragenter', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbOnDragEnter);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.codemirror.on('dragend', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.codemirror.on('dragleave', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n\n        this.codemirror.on('dragover', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbOnDragEnter);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n\n        this.codemirror.on('drop', function (cm, event) {\n            event.stopPropagation();\n            event.preventDefault();\n            if (options.imageUploadFunction) {\n                self.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.dataTransfer.files);\n            } else {\n                self.uploadImages(event.dataTransfer.files);\n            }\n        });\n\n        this.codemirror.on('paste', function (cm, event) {\n            if (options.imageUploadFunction) {\n                self.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.clipboardData.files);\n            } else {\n                self.uploadImages(event.clipboardData.files);\n            }\n        });\n    }\n}\n\n/**\n * Upload asynchronously a list of images to a server.\n *\n * Can be triggered by:\n * - drag&drop;\n * - copy-paste;\n * - the browse-file window (opened when the user clicks on the *upload-image* icon).\n * @param {FileList} files The files to upload the the server.\n * @param [onSuccess] {function} see EasyMDE.prototype.uploadImage\n * @param [onError] {function} see EasyMDE.prototype.uploadImage\n */\nEasyMDE.prototype.uploadImages = function (files, onSuccess, onError) {\n    if (files.length === 0) {\n        return;\n    }\n    var names = [];\n    for (var i = 0; i < files.length; i++) {\n        names.push(files[i].name);\n        this.uploadImage(files[i], onSuccess, onError);\n    }\n    this.updateStatusBar('upload-image', this.options.imageTexts.sbOnDrop.replace('#images_names#', names.join(', ')));\n};\n\n/**\n * Upload asynchronously a list of images to a server.\n *\n * Can be triggered by:\n * - drag&drop;\n * - copy-paste;\n * - the browse-file window (opened when the user clicks on the *upload-image* icon).\n * @param imageUploadFunction {Function} The custom function to upload the image passed in options.\n * @param {FileList} files The files to upload the the server.\n */\nEasyMDE.prototype.uploadImagesUsingCustomFunction = function (imageUploadFunction, files) {\n    if (files.length === 0) {\n        return;\n    }\n    var names = [];\n    for (var i = 0; i < files.length; i++) {\n        names.push(files[i].name);\n        this.uploadImageUsingCustomFunction(imageUploadFunction, files[i]);\n    }\n    this.updateStatusBar('upload-image', this.options.imageTexts.sbOnDrop.replace('#images_names#', names.join(', ')));\n};\n\n/**\n * Update an item in the status bar.\n * @param itemName {string} The name of the item to update (ie. 'upload-image', 'autosave', etc.).\n * @param content {string} the new content of the item to write in the status bar.\n */\nEasyMDE.prototype.updateStatusBar = function (itemName, content) {\n    if (!this.gui.statusbar) {\n        return;\n    }\n\n    var matchingClasses = this.gui.statusbar.getElementsByClassName(itemName);\n    if (matchingClasses.length === 1) {\n        this.gui.statusbar.getElementsByClassName(itemName)[0].textContent = content;\n    } else if (matchingClasses.length === 0) {\n        console.log('EasyMDE: status bar item ' + itemName + ' was not found.');\n    } else {\n        console.log('EasyMDE: Several status bar items named ' + itemName + ' was found.');\n    }\n};\n\n/**\n * Default markdown render.\n */\nEasyMDE.prototype.markdown = function (text) {\n    if (marked) {\n        // Initialize\n        var markedOptions;\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.markedOptions) {\n            markedOptions = this.options.renderingConfig.markedOptions;\n        } else {\n            markedOptions = {};\n        }\n\n        // Update options\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {\n            markedOptions.breaks = false;\n        } else {\n            markedOptions.breaks = true;\n        }\n\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true) {\n\n            /* Get HLJS from config or window */\n            var hljs = this.options.renderingConfig.hljs || window.hljs;\n\n            /* Check if HLJS loaded */\n            if (hljs) {\n                markedOptions.highlight = function (code, language) {\n                    if (language && hljs.getLanguage(language)) {\n                        return hljs.highlight(language, code).value;\n                    } else {\n                        return hljs.highlightAuto(code).value;\n                    }\n                };\n            }\n        }\n\n        // Set options\n        marked.setOptions(markedOptions);\n\n        // Convert the markdown to HTML\n        var htmlText = marked.parse(text);\n\n        // Sanitize HTML\n        if (this.options.renderingConfig && typeof this.options.renderingConfig.sanitizerFunction === 'function') {\n            htmlText = this.options.renderingConfig.sanitizerFunction.call(this, htmlText);\n        }\n\n        // Edit the HTML anchors to add 'target=\"_blank\"' by default.\n        htmlText = addAnchorTargetBlank(htmlText);\n\n        // Remove list-style when rendering checkboxes\n        htmlText = removeListStyleWhenCheckbox(htmlText);\n\n        return htmlText;\n    }\n};\n\n/**\n * Render editor to the given element.\n */\nEasyMDE.prototype.render = function (el) {\n    if (!el) {\n        el = this.element || document.getElementsByTagName('textarea')[0];\n    }\n\n    if (this._rendered && this._rendered === el) {\n        // Already rendered.\n        return;\n    }\n\n    this.element = el;\n    var options = this.options;\n\n    var self = this;\n    var keyMaps = {};\n\n    for (var key in options.shortcuts) {\n        // null stands for \"do not bind this command\"\n        if (options.shortcuts[key] !== null && bindings[key] !== null) {\n            (function (key) {\n                keyMaps[fixShortcut(options.shortcuts[key])] = function () {\n                    var action = bindings[key];\n                    if (typeof action === 'function') {\n                        action(self);\n                    } else if (typeof action === 'string') {\n                        window.open(action, '_blank');\n                    }\n                };\n            })(key);\n        }\n    }\n\n    keyMaps['Enter'] = 'newlineAndIndentContinueMarkdownList';\n    keyMaps['Tab'] = 'tabAndIndentMarkdownList';\n    keyMaps['Shift-Tab'] = 'shiftTabAndUnindentMarkdownList';\n    keyMaps['Esc'] = function (cm) {\n        if (cm.getOption('fullScreen')) toggleFullScreen(self);\n    };\n\n    this.documentOnKeyDown = function (e) {\n        e = e || window.event;\n\n        if (e.keyCode == 27) {\n            if (self.codemirror.getOption('fullScreen')) toggleFullScreen(self);\n        }\n    };\n    document.addEventListener('keydown', this.documentOnKeyDown, false);\n\n    var mode, backdrop;\n\n    // CodeMirror overlay mode\n    if (options.overlayMode) {\n        CodeMirror.defineMode('overlay-mode', function (config) {\n            return CodeMirror.overlayMode(CodeMirror.getMode(config, options.spellChecker !== false ? 'spell-checker' : 'gfm'), options.overlayMode.mode, options.overlayMode.combine);\n        });\n\n        mode = 'overlay-mode';\n        backdrop = options.parsingConfig;\n        backdrop.gitHubSpice = false;\n    } else {\n        mode = options.parsingConfig;\n        mode.name = 'gfm';\n        mode.gitHubSpice = false;\n    }\n    if (options.spellChecker !== false) {\n        mode = 'spell-checker';\n        backdrop = options.parsingConfig;\n        backdrop.name = 'gfm';\n        backdrop.gitHubSpice = false;\n\n        if (typeof options.spellChecker === 'function') {\n            options.spellChecker({\n                codeMirrorInstance: CodeMirror,\n            });\n        } else {\n            CodeMirrorSpellChecker({\n                codeMirrorInstance: CodeMirror,\n            });\n        }\n    }\n\n    // eslint-disable-next-line no-unused-vars\n    function configureMouse(cm, repeat, event) {\n        return {\n            addNew: false,\n        };\n    }\n\n    this.codemirror = CodeMirror.fromTextArea(el, {\n        mode: mode,\n        backdrop: backdrop,\n        theme: (options.theme != undefined) ? options.theme : 'easymde',\n        tabSize: (options.tabSize != undefined) ? options.tabSize : 2,\n        indentUnit: (options.tabSize != undefined) ? options.tabSize : 2,\n        indentWithTabs: (options.indentWithTabs === false) ? false : true,\n        lineNumbers: (options.lineNumbers === true) ? true : false,\n        autofocus: (options.autofocus === true) ? true : false,\n        extraKeys: keyMaps,\n        direction: options.direction,\n        lineWrapping: (options.lineWrapping === false) ? false : true,\n        allowDropFileTypes: ['text/plain'],\n        placeholder: options.placeholder || el.getAttribute('placeholder') || '',\n        styleSelectedText: (options.styleSelectedText != undefined) ? options.styleSelectedText : !isMobile(),\n        scrollbarStyle: (options.scrollbarStyle != undefined) ? options.scrollbarStyle : 'native',\n        configureMouse: configureMouse,\n        inputStyle: (options.inputStyle != undefined) ? options.inputStyle : isMobile() ? 'contenteditable' : 'textarea',\n        spellcheck: (options.nativeSpellcheck != undefined) ? options.nativeSpellcheck : true,\n        autoRefresh: (options.autoRefresh != undefined) ? options.autoRefresh : false,\n    });\n\n    this.codemirror.getScrollerElement().style.minHeight = options.minHeight;\n\n    if (typeof options.maxHeight !== 'undefined') {\n        this.codemirror.getScrollerElement().style.height = options.maxHeight;\n    }\n\n    if (options.forceSync === true) {\n        var cm = this.codemirror;\n        cm.on('change', function () {\n            cm.save();\n        });\n    }\n\n    this.gui = {};\n\n    // Wrap Codemirror with container before create toolbar, etc,\n    // to use with sideBySideFullscreen option.\n    var easyMDEContainer = document.createElement('div');\n    easyMDEContainer.classList.add('EasyMDEContainer');\n    easyMDEContainer.setAttribute('role', 'application');\n    var cmWrapper = this.codemirror.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(easyMDEContainer, cmWrapper);\n    easyMDEContainer.appendChild(cmWrapper);\n\n    if (options.toolbar !== false) {\n        this.gui.toolbar = this.createToolbar();\n    }\n    if (options.status !== false) {\n        this.gui.statusbar = this.createStatusbar();\n    }\n    if (options.autosave != undefined && options.autosave.enabled === true) {\n        this.autosave(); // use to load localstorage content\n        this.codemirror.on('change', function () {\n            clearTimeout(self._autosave_timeout);\n            self._autosave_timeout = setTimeout(function () {\n                self.autosave();\n            }, self.options.autosave.submit_delay || self.options.autosave.delay || 1000);\n        });\n    }\n\n    function calcHeight(naturalWidth, naturalHeight) {\n        var height;\n        var viewportWidth = window.getComputedStyle(document.querySelector('.CodeMirror-sizer')).width.replace('px', '');\n        if (naturalWidth < viewportWidth) {\n            height = naturalHeight + 'px';\n        } else {\n            height = (naturalHeight / naturalWidth * 100) + '%';\n        }\n        return height;\n    }\n\n    var _vm = this;\n\n\n    function assignImageBlockAttributes(parentEl, img) {\n        parentEl.setAttribute('data-img-src', img.url);\n        parentEl.setAttribute('style', '--bg-image:url(' + img.url + ');--width:' + img.naturalWidth + 'px;--height:' + calcHeight(img.naturalWidth, img.naturalHeight));\n        _vm.codemirror.setSize();\n    }\n\n    function handleImages() {\n        if (!options.previewImagesInEditor) {\n            return;\n        }\n\n        easyMDEContainer.querySelectorAll('.cm-image-marker').forEach(function (e) {\n            var parentEl = e.parentElement;\n            if (!parentEl.innerText.match(/^!\\[.*?\\]\\(.*\\)/g)) {\n                // if img pasted on the same line with other text, don't preview, preview only images on separate line\n                return;\n            }\n            if (!parentEl.hasAttribute('data-img-src')) {\n                var srcAttr = parentEl.innerText.match('\\\\((.*)\\\\)'); // might require better parsing according to markdown spec\n                if (!window.EMDEimagesCache) {\n                    window.EMDEimagesCache = {};\n                }\n\n                if (srcAttr && srcAttr.length >= 2) {\n                    var keySrc = srcAttr[1];\n\n                    if (options.imagesPreviewHandler) {\n                        var newSrc = options.imagesPreviewHandler(srcAttr[1]);\n                        // defensive check making sure the handler provided by the user returns a string\n                        if (typeof newSrc === 'string') {\n                            keySrc = newSrc;\n                        }\n                    }\n\n                    if (!window.EMDEimagesCache[keySrc]) {\n                        var img = document.createElement('img');\n                        img.onload = function () {\n                            window.EMDEimagesCache[keySrc] = {\n                                naturalWidth: img.naturalWidth,\n                                naturalHeight: img.naturalHeight,\n                                url: keySrc,\n                            };\n                            assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);\n                        };\n                        img.src = keySrc;\n                    } else {\n                        assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);\n                    }\n                }\n            }\n        });\n    }\n\n    this.codemirror.on('update', function () {\n        handleImages();\n    });\n\n    this.gui.sideBySide = this.createSideBySide();\n    this._rendered = this.element;\n\n    if (options.autofocus === true || el.autofocus) {\n        this.codemirror.focus();\n    }\n\n    // Fixes CodeMirror bug (#344)\n    var temp_cm = this.codemirror;\n    setTimeout(function () {\n        temp_cm.refresh();\n    }.bind(temp_cm), 0);\n};\n\nEasyMDE.prototype.cleanup = function () {\n    document.removeEventListener('keydown', this.documentOnKeyDown);\n};\n\n// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.\nfunction isLocalStorageAvailable() {\n    if (typeof localStorage === 'object') {\n        try {\n            localStorage.setItem('smde_localStorage', 1);\n            localStorage.removeItem('smde_localStorage');\n        } catch (e) {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    return true;\n}\n\nEasyMDE.prototype.autosave = function () {\n    if (isLocalStorageAvailable()) {\n        var easyMDE = this;\n\n        if (this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == '') {\n            console.log('EasyMDE: You must set a uniqueId to use the autosave feature');\n            return;\n        }\n\n        if (this.options.autosave.binded !== true) {\n            if (easyMDE.element.form != null && easyMDE.element.form != undefined) {\n                easyMDE.element.form.addEventListener('submit', function () {\n                    clearTimeout(easyMDE.autosaveTimeoutId);\n                    easyMDE.autosaveTimeoutId = undefined;\n\n                    localStorage.removeItem('smde_' + easyMDE.options.autosave.uniqueId);\n                });\n            }\n\n            this.options.autosave.binded = true;\n        }\n\n        if (this.options.autosave.loaded !== true) {\n            if (typeof localStorage.getItem('smde_' + this.options.autosave.uniqueId) == 'string' && localStorage.getItem('smde_' + this.options.autosave.uniqueId) != '') {\n                this.codemirror.setValue(localStorage.getItem('smde_' + this.options.autosave.uniqueId));\n                this.options.autosave.foundSavedValue = true;\n            }\n\n            this.options.autosave.loaded = true;\n        }\n\n        var value = easyMDE.value();\n        if (value !== '') {\n            localStorage.setItem('smde_' + this.options.autosave.uniqueId, value);\n        } else {\n            localStorage.removeItem('smde_' + this.options.autosave.uniqueId);\n        }\n\n        var el = document.getElementById('autosaved');\n        if (el != null && el != undefined && el != '') {\n            var d = new Date();\n            var dd = new Intl.DateTimeFormat([this.options.autosave.timeFormat.locale, 'en-US'], this.options.autosave.timeFormat.format).format(d);\n            var save = this.options.autosave.text == undefined ? 'Autosaved: ' : this.options.autosave.text;\n\n            el.innerHTML = save + dd;\n        }\n    } else {\n        console.log('EasyMDE: localStorage not available, cannot autosave');\n    }\n};\n\nEasyMDE.prototype.clearAutosavedValue = function () {\n    if (isLocalStorageAvailable()) {\n        if (this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == '') {\n            console.log('EasyMDE: You must set a uniqueId to clear the autosave value');\n            return;\n        }\n\n        localStorage.removeItem('smde_' + this.options.autosave.uniqueId);\n    } else {\n        console.log('EasyMDE: localStorage not available, cannot autosave');\n    }\n};\n\n/**\n * Open the browse-file window to upload an image to a server.\n * @param [onSuccess] {function} see EasyMDE.prototype.uploadImage\n * @param [onError] {function} see EasyMDE.prototype.uploadImage\n */\nEasyMDE.prototype.openBrowseFileWindow = function (onSuccess, onError) {\n    var self = this;\n    var imageInput = this.gui.toolbar.getElementsByClassName('imageInput')[0];\n    imageInput.click(); //dispatchEvent(new MouseEvent('click'));  // replaced with click() for IE11 compatibility.\n    function onChange(event) {\n        if (self.options.imageUploadFunction) {\n            self.uploadImagesUsingCustomFunction(self.options.imageUploadFunction, event.target.files);\n        } else {\n            self.uploadImages(event.target.files, onSuccess, onError);\n        }\n        imageInput.removeEventListener('change', onChange);\n    }\n\n    imageInput.addEventListener('change', onChange);\n};\n\n/**\n * Upload an image to the server.\n *\n * @param file {File} The image to upload, as a HTML5 File object (https://developer.mozilla.org/en-US/docs/Web/API/File)\n * @param [onSuccess] {function} A callback function to execute after the image has been successfully uploaded, with one parameter:\n * - url (string): The URL of the uploaded image.\n * @param [onError] {function} A callback function to execute when the image upload fails, with one parameter:\n * - error (string): the detailed error to display to the user (based on messages from options.errorMessages).\n */\nEasyMDE.prototype.uploadImage = function (file, onSuccess, onError) {\n    var self = this;\n    onSuccess = onSuccess || function onSuccess(imageUrl) {\n        afterImageUploaded(self, imageUrl);\n    };\n\n    function onErrorSup(errorMessage) {\n        // show error on status bar and reset after 10000ms\n        self.updateStatusBar('upload-image', errorMessage);\n\n        setTimeout(function () {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n        }, 10000);\n\n        // run custom error handler\n        if (onError && typeof onError === 'function') {\n            onError(errorMessage);\n        }\n        // run error handler from options, this alerts the message.\n        self.options.errorCallback(errorMessage);\n    }\n\n    function fillErrorMessage(errorMessage) {\n        var units = self.options.imageTexts.sizeUnits.split(',');\n        return errorMessage\n            .replace('#image_name#', file.name)\n            .replace('#image_size#', humanFileSize(file.size, units))\n            .replace('#image_max_size#', humanFileSize(self.options.imageMaxSize, units));\n    }\n\n    if (file.size > this.options.imageMaxSize) {\n        onErrorSup(fillErrorMessage(this.options.errorMessages.fileTooLarge));\n        return;\n    }\n\n    var formData = new FormData();\n    formData.append('image', file);\n\n    // insert CSRF body token if provided in config.\n    if (self.options.imageCSRFToken && !self.options.imageCSRFHeader) {\n        formData.append(self.options.imageCSRFName, self.options.imageCSRFToken);\n    }\n\n    var request = new XMLHttpRequest();\n    request.upload.onprogress = function (event) {\n        if (event.lengthComputable) {\n            var progress = '' + Math.round((event.loaded * 100) / event.total);\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbProgress.replace('#file_name#', file.name).replace('#progress#', progress));\n        }\n    };\n    request.open('POST', this.options.imageUploadEndpoint);\n\n    // insert CSRF header token if provided in config.\n    if (self.options.imageCSRFToken && self.options.imageCSRFHeader) {\n        request.setRequestHeader(self.options.imageCSRFName, self.options.imageCSRFToken);\n    }\n\n    request.onload = function () {\n        try {\n            var response = JSON.parse(this.responseText);\n        } catch (error) {\n            console.error('EasyMDE: The server did not return a valid json.');\n            onErrorSup(fillErrorMessage(self.options.errorMessages.importError));\n            return;\n        }\n        if (this.status === 200 && response && !response.error && response.data && response.data.filePath) {\n            onSuccess((self.options.imagePathAbsolute ? '' : (window.location.origin + '/')) + response.data.filePath);\n        } else {\n            if (response.error && response.error in self.options.errorMessages) {  // preformatted error message\n                onErrorSup(fillErrorMessage(self.options.errorMessages[response.error]));\n            } else if (response.error) {  // server side generated error message\n                onErrorSup(fillErrorMessage(response.error));\n            } else {  //unknown error\n                console.error('EasyMDE: Received an unexpected response after uploading the image.'\n                    + this.status + ' (' + this.statusText + ')');\n                onErrorSup(fillErrorMessage(self.options.errorMessages.importError));\n            }\n        }\n    };\n\n    request.onerror = function (event) {\n        console.error('EasyMDE: An unexpected error occurred when trying to upload the image.'\n            + event.target.status + ' (' + event.target.statusText + ')');\n        onErrorSup(self.options.errorMessages.importError);\n    };\n\n    request.send(formData);\n\n};\n\n/**\n * Upload an image to the server using a custom upload function.\n *\n * @param imageUploadFunction {Function} The custom function to upload the image passed in options\n * @param file {File} The image to upload, as a HTML5 File object (https://developer.mozilla.org/en-US/docs/Web/API/File).\n */\nEasyMDE.prototype.uploadImageUsingCustomFunction = function (imageUploadFunction, file) {\n    var self = this;\n\n    function onSuccess(imageUrl) {\n        afterImageUploaded(self, imageUrl);\n    }\n\n    function onError(errorMessage) {\n        var filledErrorMessage = fillErrorMessage(errorMessage);\n        // show error on status bar and reset after 10000ms\n        self.updateStatusBar('upload-image', filledErrorMessage);\n\n        setTimeout(function () {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n        }, 10000);\n\n        // run error handler from options, this alerts the message.\n        self.options.errorCallback(filledErrorMessage);\n    }\n\n    function fillErrorMessage(errorMessage) {\n        var units = self.options.imageTexts.sizeUnits.split(',');\n        return errorMessage\n            .replace('#image_name#', file.name)\n            .replace('#image_size#', humanFileSize(file.size, units))\n            .replace('#image_max_size#', humanFileSize(self.options.imageMaxSize, units));\n    }\n\n    imageUploadFunction.apply(this, [file, onSuccess, onError]);\n};\n\nEasyMDE.prototype.setPreviewMaxHeight = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n\n    // Calc preview max height\n    var paddingTop = parseInt(window.getComputedStyle(wrapper).paddingTop);\n    var borderTopWidth = parseInt(window.getComputedStyle(wrapper).borderTopWidth);\n    var optionsMaxHeight = parseInt(this.options.maxHeight);\n    var wrapperMaxHeight = optionsMaxHeight + paddingTop * 2 + borderTopWidth * 2;\n    var previewMaxHeight = wrapperMaxHeight.toString() + 'px';\n\n    preview.style.height = previewMaxHeight;\n};\n\nEasyMDE.prototype.createSideBySide = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n\n    if (!preview || !preview.classList.contains('editor-preview-side')) {\n        preview = document.createElement('div');\n        preview.className = 'editor-preview-side';\n\n        if (this.options.previewClass) {\n\n            if (Array.isArray(this.options.previewClass)) {\n                for (var i = 0; i < this.options.previewClass.length; i++) {\n                    preview.classList.add(this.options.previewClass[i]);\n                }\n\n            } else if (typeof this.options.previewClass === 'string') {\n                preview.classList.add(this.options.previewClass);\n            }\n        }\n\n        wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);\n    }\n\n    if (typeof this.options.maxHeight !== 'undefined') {\n        this.setPreviewMaxHeight();\n    }\n\n    if (this.options.syncSideBySidePreviewScroll === false) return preview;\n    // Syncs scroll  editor -> preview\n    var cScroll = false;\n    var pScroll = false;\n    cm.on('scroll', function (v) {\n        if (cScroll) {\n            cScroll = false;\n            return;\n        }\n        pScroll = true;\n        var height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;\n        var ratio = parseFloat(v.getScrollInfo().top) / height;\n        var move = (preview.scrollHeight - preview.clientHeight) * ratio;\n        preview.scrollTop = move;\n    });\n\n    // Syncs scroll  preview -> editor\n    preview.onscroll = function () {\n        if (pScroll) {\n            pScroll = false;\n            return;\n        }\n        cScroll = true;\n        var height = preview.scrollHeight - preview.clientHeight;\n        var ratio = parseFloat(preview.scrollTop) / height;\n        var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;\n        cm.scrollTo(0, move);\n    };\n    return preview;\n};\n\nEasyMDE.prototype.createToolbar = function (items) {\n    items = items || this.options.toolbar;\n\n    if (!items || items.length === 0) {\n        return;\n    }\n    var i;\n    for (i = 0; i < items.length; i++) {\n        if (toolbarBuiltInButtons[items[i]] != undefined) {\n            items[i] = toolbarBuiltInButtons[items[i]];\n        }\n    }\n\n    var bar = document.createElement('div');\n    bar.className = 'editor-toolbar';\n    bar.setAttribute('role', 'toolbar');\n\n    var self = this;\n\n    var toolbarData = {};\n    self.toolbar = items;\n\n    for (i = 0; i < items.length; i++) {\n        if (items[i].name == 'guide' && self.options.toolbarGuideIcon === false)\n            continue;\n\n        if (self.options.hideIcons && self.options.hideIcons.indexOf(items[i].name) != -1)\n            continue;\n\n        // Fullscreen does not work well on mobile devices (even tablets)\n        // In the future, hopefully this can be resolved\n        if ((items[i].name == 'fullscreen' || items[i].name == 'side-by-side') && isMobile())\n            continue;\n\n\n        // Don't include trailing separators\n        if (items[i] === '|') {\n            var nonSeparatorIconsFollow = false;\n\n            for (var x = (i + 1); x < items.length; x++) {\n                if (items[x] !== '|' && (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {\n                    nonSeparatorIconsFollow = true;\n                }\n            }\n\n            if (!nonSeparatorIconsFollow)\n                continue;\n        }\n\n\n        // Create the icon and append to the toolbar\n        (function (item) {\n            var el;\n            if (item === '|') {\n                el = createSep();\n            } else if (item.children) {\n                el = createToolbarDropdown(item, self.options.toolbarTips, self.options.shortcuts, self);\n            } else {\n                el = createToolbarButton(item, true, self.options.toolbarTips, self.options.shortcuts, 'button', self);\n            }\n\n\n            toolbarData[item.name || item] = el;\n            bar.appendChild(el);\n\n            // Create the input element (ie. <input type='file'>), used among\n            // with the 'import-image' icon to open the browse-file window.\n            if (item.name === 'upload-image') {\n                var imageInput = document.createElement('input');\n                imageInput.className = 'imageInput';\n                imageInput.type = 'file';\n                imageInput.multiple = true;\n                imageInput.name = 'image';\n                imageInput.accept = self.options.imageAccept;\n                imageInput.style.display = 'none';\n                imageInput.style.opacity = 0;\n                bar.appendChild(imageInput);\n            }\n        })(items[i]);\n    }\n\n    self.toolbar_div = bar;\n    self.toolbarElements = toolbarData;\n\n    var cm = this.codemirror;\n    cm.on('cursorActivity', function () {\n        var stat = getState(cm);\n\n        for (var key in toolbarData) {\n            (function (key) {\n                var el = toolbarData[key];\n                if (stat[key]) {\n                    el.classList.add('active');\n                } else if (key != 'fullscreen' && key != 'side-by-side') {\n                    el.classList.remove('active');\n                }\n            })(key);\n        }\n    });\n\n    var cmWrapper = cm.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(bar, cmWrapper);\n    return bar;\n};\n\nEasyMDE.prototype.createStatusbar = function (status) {\n    // Initialize\n    status = status || this.options.status;\n    var options = this.options;\n    var cm = this.codemirror;\n\n    // Make sure the status variable is valid\n    if (!status || status.length === 0) {\n        return;\n    }\n\n    // Set up the built-in items\n    var items = [];\n    var i, onUpdate, onActivity, defaultValue;\n\n    for (i = 0; i < status.length; i++) {\n        // Reset some values\n        onUpdate = undefined;\n        onActivity = undefined;\n        defaultValue = undefined;\n\n\n        // Handle if custom or not\n        if (typeof status[i] === 'object') {\n            items.push({\n                className: status[i].className,\n                defaultValue: status[i].defaultValue,\n                onUpdate: status[i].onUpdate,\n                onActivity: status[i].onActivity,\n            });\n        } else {\n            var name = status[i];\n\n            if (name === 'words') {\n                defaultValue = function (el) {\n                    el.innerHTML = wordCount(cm.getValue());\n                };\n                onUpdate = function (el) {\n                    el.innerHTML = wordCount(cm.getValue());\n                };\n            } else if (name === 'lines') {\n                defaultValue = function (el) {\n                    el.innerHTML = cm.lineCount();\n                };\n                onUpdate = function (el) {\n                    el.innerHTML = cm.lineCount();\n                };\n            } else if (name === 'cursor') {\n                defaultValue = function (el) {\n                    el.innerHTML = '1:1';\n                };\n                onActivity = function (el) {\n                    var pos = cm.getCursor();\n                    var posLine = pos.line + 1;\n                    var posColumn = pos.ch + 1;\n                    el.innerHTML = posLine + ':' + posColumn;\n                };\n            } else if (name === 'autosave') {\n                defaultValue = function (el) {\n                    if (options.autosave != undefined && options.autosave.enabled === true) {\n                        el.setAttribute('id', 'autosaved');\n                    }\n                };\n            } else if (name === 'upload-image') {\n                defaultValue = function (el) {\n                    el.innerHTML = options.imageTexts.sbInit;\n                };\n            }\n\n            items.push({\n                className: name,\n                defaultValue: defaultValue,\n                onUpdate: onUpdate,\n                onActivity: onActivity,\n            });\n        }\n    }\n\n\n    // Create element for the status bar\n    var bar = document.createElement('div');\n    bar.className = 'editor-statusbar';\n\n\n    // Create a new span for each item\n    for (i = 0; i < items.length; i++) {\n        // Store in temporary variable\n        var item = items[i];\n\n\n        // Create span element\n        var el = document.createElement('span');\n        el.className = item.className;\n\n\n        // Ensure the defaultValue is a function\n        if (typeof item.defaultValue === 'function') {\n            item.defaultValue(el);\n        }\n\n\n        // Ensure the onUpdate is a function\n        if (typeof item.onUpdate === 'function') {\n            // Create a closure around the span of the current action, then execute the onUpdate handler\n            this.codemirror.on('update', (function (el, item) {\n                return function () {\n                    item.onUpdate(el);\n                };\n            }(el, item)));\n        }\n        if (typeof item.onActivity === 'function') {\n            // Create a closure around the span of the current action, then execute the onActivity handler\n            this.codemirror.on('cursorActivity', (function (el, item) {\n                return function () {\n                    item.onActivity(el);\n                };\n            }(el, item)));\n        }\n\n\n        // Append the item to the status bar\n        bar.appendChild(el);\n    }\n\n\n    // Insert the status bar into the DOM\n    var cmWrapper = this.codemirror.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);\n    return bar;\n};\n\n/**\n * Get or set the text content.\n */\nEasyMDE.prototype.value = function (val) {\n    var cm = this.codemirror;\n    if (val === undefined) {\n        return cm.getValue();\n    } else {\n        cm.getDoc().setValue(val);\n        if (this.isPreviewActive()) {\n            var wrapper = cm.getWrapperElement();\n            var preview = wrapper.lastChild;\n            var preview_result = this.options.previewRender(val, preview);\n            if (preview_result !== null) {\n                preview.innerHTML = preview_result;\n            }\n\n        }\n        return this;\n    }\n};\n\n\n/**\n * Bind static methods for exports.\n */\nEasyMDE.toggleBold = toggleBold;\nEasyMDE.toggleItalic = toggleItalic;\nEasyMDE.toggleStrikethrough = toggleStrikethrough;\nEasyMDE.toggleBlockquote = toggleBlockquote;\nEasyMDE.toggleHeadingSmaller = toggleHeadingSmaller;\nEasyMDE.toggleHeadingBigger = toggleHeadingBigger;\nEasyMDE.toggleHeading1 = toggleHeading1;\nEasyMDE.toggleHeading2 = toggleHeading2;\nEasyMDE.toggleHeading3 = toggleHeading3;\nEasyMDE.toggleHeading4 = toggleHeading4;\nEasyMDE.toggleHeading5 = toggleHeading5;\nEasyMDE.toggleHeading6 = toggleHeading6;\nEasyMDE.toggleCodeBlock = toggleCodeBlock;\nEasyMDE.toggleUnorderedList = toggleUnorderedList;\nEasyMDE.toggleOrderedList = toggleOrderedList;\nEasyMDE.cleanBlock = cleanBlock;\nEasyMDE.drawLink = drawLink;\nEasyMDE.drawImage = drawImage;\nEasyMDE.drawUploadedImage = drawUploadedImage;\nEasyMDE.drawTable = drawTable;\nEasyMDE.drawHorizontalRule = drawHorizontalRule;\nEasyMDE.undo = undo;\nEasyMDE.redo = redo;\nEasyMDE.togglePreview = togglePreview;\nEasyMDE.toggleSideBySide = toggleSideBySide;\nEasyMDE.toggleFullScreen = toggleFullScreen;\n\n/**\n * Bind instance methods for exports.\n */\nEasyMDE.prototype.toggleBold = function () {\n    toggleBold(this);\n};\nEasyMDE.prototype.toggleItalic = function () {\n    toggleItalic(this);\n};\nEasyMDE.prototype.toggleStrikethrough = function () {\n    toggleStrikethrough(this);\n};\nEasyMDE.prototype.toggleBlockquote = function () {\n    toggleBlockquote(this);\n};\nEasyMDE.prototype.toggleHeadingSmaller = function () {\n    toggleHeadingSmaller(this);\n};\nEasyMDE.prototype.toggleHeadingBigger = function () {\n    toggleHeadingBigger(this);\n};\nEasyMDE.prototype.toggleHeading1 = function () {\n    toggleHeading1(this);\n};\nEasyMDE.prototype.toggleHeading2 = function () {\n    toggleHeading2(this);\n};\nEasyMDE.prototype.toggleHeading3 = function () {\n    toggleHeading3(this);\n};\nEasyMDE.prototype.toggleHeading4 = function () {\n    toggleHeading4(this);\n};\nEasyMDE.prototype.toggleHeading5 = function () {\n    toggleHeading5(this);\n};\nEasyMDE.prototype.toggleHeading6 = function () {\n    toggleHeading6(this);\n};\nEasyMDE.prototype.toggleCodeBlock = function () {\n    toggleCodeBlock(this);\n};\nEasyMDE.prototype.toggleUnorderedList = function () {\n    toggleUnorderedList(this);\n};\nEasyMDE.prototype.toggleOrderedList = function () {\n    toggleOrderedList(this);\n};\nEasyMDE.prototype.cleanBlock = function () {\n    cleanBlock(this);\n};\nEasyMDE.prototype.drawLink = function () {\n    drawLink(this);\n};\nEasyMDE.prototype.drawImage = function () {\n    drawImage(this);\n};\nEasyMDE.prototype.drawUploadedImage = function () {\n    drawUploadedImage(this);\n};\nEasyMDE.prototype.drawTable = function () {\n    drawTable(this);\n};\nEasyMDE.prototype.drawHorizontalRule = function () {\n    drawHorizontalRule(this);\n};\nEasyMDE.prototype.undo = function () {\n    undo(this);\n};\nEasyMDE.prototype.redo = function () {\n    redo(this);\n};\nEasyMDE.prototype.togglePreview = function () {\n    togglePreview(this);\n};\nEasyMDE.prototype.toggleSideBySide = function () {\n    toggleSideBySide(this);\n};\nEasyMDE.prototype.toggleFullScreen = function () {\n    toggleFullScreen(this);\n};\n\nEasyMDE.prototype.isPreviewActive = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.lastChild;\n\n    return preview.classList.contains('editor-preview-active');\n};\n\nEasyMDE.prototype.isSideBySideActive = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n\n    return preview.classList.contains('editor-preview-active-side');\n};\n\nEasyMDE.prototype.isFullscreenActive = function () {\n    var cm = this.codemirror;\n\n    return cm.getOption('fullScreen');\n};\n\nEasyMDE.prototype.getState = function () {\n    var cm = this.codemirror;\n\n    return getState(cm);\n};\n\nEasyMDE.prototype.toTextArea = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var easyMDEContainer = wrapper.parentNode;\n\n    if (easyMDEContainer) {\n        if (this.gui.toolbar) {\n            easyMDEContainer.removeChild(this.gui.toolbar);\n        }\n        if (this.gui.statusbar) {\n            easyMDEContainer.removeChild(this.gui.statusbar);\n        }\n        if (this.gui.sideBySide) {\n            easyMDEContainer.removeChild(this.gui.sideBySide);\n        }\n    }\n\n    // Unwrap easyMDEcontainer before codemirror toTextArea() call\n    easyMDEContainer.parentNode.insertBefore(wrapper, easyMDEContainer);\n    easyMDEContainer.remove();\n\n    cm.toTextArea();\n\n    if (this.autosaveTimeoutId) {\n        clearTimeout(this.autosaveTimeoutId);\n        this.autosaveTimeoutId = undefined;\n        this.clearAutosavedValue();\n    }\n};\n\nmodule.exports = EasyMDE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9zcmMvanMvZWFzeW1kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFZO0FBQ3JDLG1CQUFPLENBQUMseUdBQXVDO0FBQy9DLG1CQUFPLENBQUMsdUZBQXNCO0FBQzlCLG1CQUFPLENBQUMsMkdBQXdDO0FBQ2hELG1CQUFPLENBQUMsdUdBQXNDO0FBQzlDLG1CQUFPLENBQUMsK0ZBQWtDO0FBQzFDLG1CQUFPLENBQUMsNkdBQXlDO0FBQ2pELG1CQUFPLENBQUMsNkdBQXlDO0FBQ2pELG1CQUFPLENBQUMsdUhBQThDO0FBQ3RELG1CQUFPLENBQUMsNkdBQXlDO0FBQ2pELG1CQUFPLENBQUMsbUZBQTRCO0FBQ3BDLG1CQUFPLENBQUMsbUZBQTRCO0FBQ3BDLDZCQUE2QixtQkFBTyxDQUFDLHVHQUEwQjtBQUMvRCxhQUFhLHdGQUF3Qjs7O0FBR3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0Esd0VBQXdFLG1DQUFtQztBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7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QUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9zcmMvanMvZWFzeW1kZS5qcz8xNDYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBDb2RlTWlycm9yID0gcmVxdWlyZSgnY29kZW1pcnJvcicpO1xucmVxdWlyZSgnY29kZW1pcnJvci9hZGRvbi9lZGl0L2NvbnRpbnVlbGlzdC5qcycpO1xucmVxdWlyZSgnLi9jb2RlbWlycm9yL3RhYmxpc3QnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvYWRkb24vZGlzcGxheS9mdWxsc2NyZWVuLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL21vZGUvbWFya2Rvd24vbWFya2Rvd24uanMnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvYWRkb24vbW9kZS9vdmVybGF5LmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvcGxhY2Vob2xkZXIuanMnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvYWRkb24vZGlzcGxheS9hdXRvcmVmcmVzaC5qcycpO1xucmVxdWlyZSgnY29kZW1pcnJvci9hZGRvbi9zZWxlY3Rpb24vbWFyay1zZWxlY3Rpb24uanMnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvYWRkb24vc2VhcmNoL3NlYXJjaGN1cnNvci5qcycpO1xucmVxdWlyZSgnY29kZW1pcnJvci9tb2RlL2dmbS9nZm0uanMnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzJyk7XG52YXIgQ29kZU1pcnJvclNwZWxsQ2hlY2tlciA9IHJlcXVpcmUoJ2NvZGVtaXJyb3Itc3BlbGwtY2hlY2tlcicpO1xudmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpLm1hcmtlZDtcblxuXG4vLyBTb21lIHZhcmlhYmxlc1xudmFyIGlzTWFjID0gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xudmFyIGFuY2hvclRvRXh0ZXJuYWxSZWdleCA9IG5ldyBSZWdFeHAoLyg8YS4qP2h0dHBzPzpcXC9cXC8uKj9bXmFdPikrPy9nKTtcblxuLy8gTWFwcGluZyBvZiBhY3Rpb25zIHRoYXQgY2FuIGJlIGJvdW5kIHRvIGtleWJvYXJkIHNob3J0Y3V0cyBvciB0b29sYmFyIGJ1dHRvbnNcbnZhciBiaW5kaW5ncyA9IHtcbiAgICAndG9nZ2xlQm9sZCc6IHRvZ2dsZUJvbGQsXG4gICAgJ3RvZ2dsZUl0YWxpYyc6IHRvZ2dsZUl0YWxpYyxcbiAgICAnZHJhd0xpbmsnOiBkcmF3TGluayxcbiAgICAndG9nZ2xlSGVhZGluZ1NtYWxsZXInOiB0b2dnbGVIZWFkaW5nU21hbGxlcixcbiAgICAndG9nZ2xlSGVhZGluZ0JpZ2dlcic6IHRvZ2dsZUhlYWRpbmdCaWdnZXIsXG4gICAgJ2RyYXdJbWFnZSc6IGRyYXdJbWFnZSxcbiAgICAndG9nZ2xlQmxvY2txdW90ZSc6IHRvZ2dsZUJsb2NrcXVvdGUsXG4gICAgJ3RvZ2dsZU9yZGVyZWRMaXN0JzogdG9nZ2xlT3JkZXJlZExpc3QsXG4gICAgJ3RvZ2dsZVVub3JkZXJlZExpc3QnOiB0b2dnbGVVbm9yZGVyZWRMaXN0LFxuICAgICd0b2dnbGVDb2RlQmxvY2snOiB0b2dnbGVDb2RlQmxvY2ssXG4gICAgJ3RvZ2dsZVByZXZpZXcnOiB0b2dnbGVQcmV2aWV3LFxuICAgICd0b2dnbGVTdHJpa2V0aHJvdWdoJzogdG9nZ2xlU3RyaWtldGhyb3VnaCxcbiAgICAndG9nZ2xlSGVhZGluZzEnOiB0b2dnbGVIZWFkaW5nMSxcbiAgICAndG9nZ2xlSGVhZGluZzInOiB0b2dnbGVIZWFkaW5nMixcbiAgICAndG9nZ2xlSGVhZGluZzMnOiB0b2dnbGVIZWFkaW5nMyxcbiAgICAndG9nZ2xlSGVhZGluZzQnOiB0b2dnbGVIZWFkaW5nNCxcbiAgICAndG9nZ2xlSGVhZGluZzUnOiB0b2dnbGVIZWFkaW5nNSxcbiAgICAndG9nZ2xlSGVhZGluZzYnOiB0b2dnbGVIZWFkaW5nNixcbiAgICAnY2xlYW5CbG9jayc6IGNsZWFuQmxvY2ssXG4gICAgJ2RyYXdUYWJsZSc6IGRyYXdUYWJsZSxcbiAgICAnZHJhd0hvcml6b250YWxSdWxlJzogZHJhd0hvcml6b250YWxSdWxlLFxuICAgICd1bmRvJzogdW5kbyxcbiAgICAncmVkbyc6IHJlZG8sXG4gICAgJ3RvZ2dsZVNpZGVCeVNpZGUnOiB0b2dnbGVTaWRlQnlTaWRlLFxuICAgICd0b2dnbGVGdWxsU2NyZWVuJzogdG9nZ2xlRnVsbFNjcmVlbixcbn07XG5cbnZhciBzaG9ydGN1dHMgPSB7XG4gICAgJ3RvZ2dsZUJvbGQnOiAnQ21kLUInLFxuICAgICd0b2dnbGVJdGFsaWMnOiAnQ21kLUknLFxuICAgICdkcmF3TGluayc6ICdDbWQtSycsXG4gICAgJ3RvZ2dsZUhlYWRpbmdTbWFsbGVyJzogJ0NtZC1IJyxcbiAgICAndG9nZ2xlSGVhZGluZ0JpZ2dlcic6ICdTaGlmdC1DbWQtSCcsXG4gICAgJ3RvZ2dsZUhlYWRpbmcxJzogJ0N0cmwrQWx0KzEnLFxuICAgICd0b2dnbGVIZWFkaW5nMic6ICdDdHJsK0FsdCsyJyxcbiAgICAndG9nZ2xlSGVhZGluZzMnOiAnQ3RybCtBbHQrMycsXG4gICAgJ3RvZ2dsZUhlYWRpbmc0JzogJ0N0cmwrQWx0KzQnLFxuICAgICd0b2dnbGVIZWFkaW5nNSc6ICdDdHJsK0FsdCs1JyxcbiAgICAndG9nZ2xlSGVhZGluZzYnOiAnQ3RybCtBbHQrNicsXG4gICAgJ2NsZWFuQmxvY2snOiAnQ21kLUUnLFxuICAgICdkcmF3SW1hZ2UnOiAnQ21kLUFsdC1JJyxcbiAgICAndG9nZ2xlQmxvY2txdW90ZSc6ICdDbWQtXFwnJyxcbiAgICAndG9nZ2xlT3JkZXJlZExpc3QnOiAnQ21kLUFsdC1MJyxcbiAgICAndG9nZ2xlVW5vcmRlcmVkTGlzdCc6ICdDbWQtTCcsXG4gICAgJ3RvZ2dsZUNvZGVCbG9jayc6ICdDbWQtQWx0LUMnLFxuICAgICd0b2dnbGVQcmV2aWV3JzogJ0NtZC1QJyxcbiAgICAndG9nZ2xlU2lkZUJ5U2lkZSc6ICdGOScsXG4gICAgJ3RvZ2dsZUZ1bGxTY3JlZW4nOiAnRjExJyxcbn07XG5cbnZhciBnZXRCaW5kaW5nTmFtZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGJpbmRpbmdzKSB7XG4gICAgICAgIGlmIChiaW5kaW5nc1trZXldID09PSBmKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxudmFyIGlzTW9iaWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGVjayA9IGZhbHNlO1xuICAgIChmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWlub3xhbmRyb2lkfGlwYWR8cGxheWJvb2t8c2lsay9pLnRlc3QoYSkgfHwgLzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHMtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YnctKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG0tfGNlbGx8Y2h0bXxjbGRjfGNtZC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGMtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2YtNXxnLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGQtKG18cHx0KXxoZWktfGhpKHB0fHRhKXxocCggaXxpcCl8aHMtY3xodChjKC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2MtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fC1bYS13XSl8bGlid3xseW54fG0xLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKS18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG4tMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0LWd8cWEtYXxxYygwN3wxMnwyMXwzMnw2MHwtWzItN118aS0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoLXxvb3xwLSl8c2RrXFwvfHNlKGMoLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2gtfHNoYXJ8c2llKC18bSl8c2stMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoLXx2LXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbC18dGRnLXx0ZWwoaXxtKXx0aW0tfHQtbW98dG8ocGx8c2gpfHRzKDcwfG0tfG0zfG01KXx0eC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYygtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzLXx5b3VyfHpldG98enRlLS9pLnRlc3QoYS5zdWJzdHIoMCwgNCkpKSBjaGVjayA9IHRydWU7XG4gICAgfSkobmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYSk7XG4gICAgcmV0dXJuIGNoZWNrO1xufTtcblxuLyoqXG4gKiBNb2RpZnkgSFRNTCB0byBhZGQgJ3RhcmdldD1cIl9ibGFua1wiJyB0byBsaW5rcyBzbyB0aGV5IG9wZW4gaW4gbmV3IHRhYnMgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sVGV4dCAtIEhUTUwgdG8gYmUgbW9kaWZpZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtb2RpZmllZCBIVE1MIHRleHQuXG4gKi9cbmZ1bmN0aW9uIGFkZEFuY2hvclRhcmdldEJsYW5rKGh0bWxUZXh0KSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIHdoaWxlICgobWF0Y2ggPSBhbmNob3JUb0V4dGVybmFsUmVnZXguZXhlYyhodG1sVGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdpdGggb25seSBvbmUgY2FwdHVyZSBncm91cCBpbiB0aGUgUmVnRXhwLCB3ZSBjYW4gc2FmZWx5IHRha2UgdGhlIGZpcnN0IGluZGV4IGZyb20gdGhlIG1hdGNoLlxuICAgICAgICB2YXIgbGlua1N0cmluZyA9IG1hdGNoWzBdO1xuXG4gICAgICAgIGlmIChsaW5rU3RyaW5nLmluZGV4T2YoJ3RhcmdldD0nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBmaXhlZExpbmtTdHJpbmcgPSBsaW5rU3RyaW5nLnJlcGxhY2UoLz4kLywgJyB0YXJnZXQ9XCJfYmxhbmtcIj4nKTtcbiAgICAgICAgICAgIGh0bWxUZXh0ID0gaHRtbFRleHQucmVwbGFjZShsaW5rU3RyaW5nLCBmaXhlZExpbmtTdHJpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sVGV4dDtcbn1cblxuLyoqXG4gKiBNb2RpZnkgSFRNTCB0byByZW1vdmUgdGhlIGxpc3Qtc3R5bGUgd2hlbiByZW5kZXJpbmcgY2hlY2tib3hlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sVGV4dCAtIEhUTUwgdG8gYmUgbW9kaWZpZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtb2RpZmllZCBIVE1MIHRleHQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RTdHlsZVdoZW5DaGVja2JveChodG1sVGV4dCkge1xuXG4gICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICB2YXIgaHRtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoaHRtbFRleHQsICd0ZXh0L2h0bWwnKTtcbiAgICB2YXIgbGlzdEl0ZW1zID0gaHRtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaXN0SXRlbSA9IGxpc3RJdGVtc1tpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpc3RJdGVtLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbGlzdEl0ZW1DaGlsZCA9IGxpc3RJdGVtLmNoaWxkcmVuW2pdO1xuXG4gICAgICAgICAgICBpZiAobGlzdEl0ZW1DaGlsZCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgbGlzdEl0ZW1DaGlsZC50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICAgICAgLy8gRnJvbSBHaXRodWI6IG1hcmdpbjogMCAuMmVtIC4yNWVtIC0xLjZlbTtcbiAgICAgICAgICAgICAgICBsaXN0SXRlbS5zdHlsZS5tYXJnaW5MZWZ0ID0gJy0xLjVlbSc7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0uc3R5bGUubGlzdFN0eWxlVHlwZSA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBodG1sRG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUw7XG59XG5cbi8qKlxuICogRml4IHNob3J0Y3V0LiBNYWMgdXNlIENvbW1hbmQsIG90aGVycyB1c2UgQ3RybC5cbiAqL1xuZnVuY3Rpb24gZml4U2hvcnRjdXQobmFtZSkge1xuICAgIGlmIChpc01hYykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKCdDdHJsJywgJ0NtZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoJ0NtZCcsICdDdHJsJyk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuXG4vKipcbiAqIENyZWF0ZSBkcm9wZG93biBibG9ja1xuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sYmFyRHJvcGRvd24ob3B0aW9ucywgZW5hYmxlVG9vbHRpcHMsIHNob3J0Y3V0cywgcGFyZW50KSB7XG4gICAgdmFyIGVsID0gY3JlYXRlVG9vbGJhckJ1dHRvbihvcHRpb25zLCBmYWxzZSwgZW5hYmxlVG9vbHRpcHMsIHNob3J0Y3V0cywgJ2J1dHRvbicsIHBhcmVudCk7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnZWFzeW1kZS1kcm9wZG93bicpO1xuXG4gICAgZWwub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuZm9jdXMoKTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdlYXN5bWRlLWRyb3Bkb3duLWNvbnRlbnQnO1xuICAgIGZvciAodmFyIGNoaWxkcmVuSW5kZXggPSAwOyBjaGlsZHJlbkluZGV4IDwgb3B0aW9ucy5jaGlsZHJlbi5sZW5ndGg7IGNoaWxkcmVuSW5kZXgrKykge1xuXG4gICAgICAgIHZhciBjaGlsZCA9IG9wdGlvbnMuY2hpbGRyZW5bY2hpbGRyZW5JbmRleF07XG4gICAgICAgIHZhciBjaGlsZEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgJiYgY2hpbGQgaW4gdG9vbGJhckJ1aWx0SW5CdXR0b25zKSB7XG4gICAgICAgICAgICBjaGlsZEVsZW1lbnQgPSBjcmVhdGVUb29sYmFyQnV0dG9uKHRvb2xiYXJCdWlsdEluQnV0dG9uc1tjaGlsZF0sIHRydWUsIGVuYWJsZVRvb2x0aXBzLCBzaG9ydGN1dHMsICdidXR0b24nLCBwYXJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGRFbGVtZW50ID0gY3JlYXRlVG9vbGJhckJ1dHRvbihjaGlsZCwgdHJ1ZSwgZW5hYmxlVG9vbHRpcHMsIHNob3J0Y3V0cywgJ2J1dHRvbicsIHBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9LCBmYWxzZSk7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoY2hpbGRFbGVtZW50KTtcbiAgICB9XG4gICAgZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIENyZWF0ZSBidXR0b24gZWxlbWVudCBmb3IgdG9vbGJhci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9vbGJhckJ1dHRvbihvcHRpb25zLCBlbmFibGVBY3Rpb25zLCBlbmFibGVUb29sdGlwcywgc2hvcnRjdXRzLCBtYXJrdXAsIHBhcmVudCkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobWFya3VwKTtcblxuICAgIC8vIEFkZCAnY3VzdG9tJyBhdHRyaWJ1dGVzIGFzIGVhcmx5IGFzIHBvc3NpYmxlLCBzbyB0aGF0ICdvZmZpY2lhbCcgYXR0cmlidXRlcyB3aWxsIG5ldmVyIGJlIG92ZXJ3cml0dGVuLlxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBvcHRpb25zLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2xhc3NOYW1lUHJlZml4ID0gcGFyZW50Lm9wdGlvbnMudG9vbGJhckJ1dHRvbkNsYXNzUHJlZml4ID8gcGFyZW50Lm9wdGlvbnMudG9vbGJhckJ1dHRvbkNsYXNzUHJlZml4ICsgJy0nIDogJyc7XG4gICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lUHJlZml4ICsgb3B0aW9ucy5uYW1lO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgndHlwZScsIG1hcmt1cCk7XG4gICAgZW5hYmxlVG9vbHRpcHMgPSAoZW5hYmxlVG9vbHRpcHMgPT0gdW5kZWZpbmVkKSA/IHRydWUgOiBlbmFibGVUb29sdGlwcztcblxuICAgIGlmIChvcHRpb25zLnRleHQpIHtcbiAgICAgICAgZWwuaW5uZXJUZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgIH1cblxuICAgIC8vIFByb3Blcmx5IGhhbmRsZSBjdXN0b20gc2hvcnRjdXRzXG4gICAgaWYgKG9wdGlvbnMubmFtZSAmJiBvcHRpb25zLm5hbWUgaW4gc2hvcnRjdXRzKSB7XG4gICAgICAgIGJpbmRpbmdzW29wdGlvbnMubmFtZV0gPSBvcHRpb25zLmFjdGlvbjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBlbmFibGVUb29sdGlwcykge1xuICAgICAgICBlbC50aXRsZSA9IGNyZWF0ZVRvb2x0aXAob3B0aW9ucy50aXRsZSwgb3B0aW9ucy5hY3Rpb24sIHNob3J0Y3V0cyk7XG5cbiAgICAgICAgaWYgKGlzTWFjKSB7XG4gICAgICAgICAgICBlbC50aXRsZSA9IGVsLnRpdGxlLnJlcGxhY2UoJ0N0cmwnLCAn4oyYJyk7XG4gICAgICAgICAgICBlbC50aXRsZSA9IGVsLnRpdGxlLnJlcGxhY2UoJ0FsdCcsICfijKUnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRpdGxlKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIG9wdGlvbnMudGl0bGUpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vRGlzYWJsZSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCduby1kaXNhYmxlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubm9Nb2JpbGUpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbm8tbW9iaWxlJyk7XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBlcnJvcnMgaWYgdGhlcmUgaXMgbm8gY2xhc3MgbmFtZSBpbiBjdXN0b20gb3B0aW9uc1xuICAgIHZhciBjbGFzc05hbWVQYXJ0cyA9IFtdO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jbGFzc05hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNsYXNzTmFtZVBhcnRzID0gb3B0aW9ucy5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICB9XG5cbiAgICAvLyBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggc2ltcGxlLW1hcmtkb3duLWVkaXRvciBieSBhZGRpbmcgY3VzdG9tIGNsYXNzZXMgdG8gdGhlIGJ1dHRvbi5cbiAgICB2YXIgaWNvbkNsYXNzZXMgPSBbXTtcbiAgICBmb3IgKHZhciBjbGFzc05hbWVJbmRleCA9IDA7IGNsYXNzTmFtZUluZGV4IDwgY2xhc3NOYW1lUGFydHMubGVuZ3RoOyBjbGFzc05hbWVJbmRleCsrKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWVQYXJ0ID0gY2xhc3NOYW1lUGFydHNbY2xhc3NOYW1lSW5kZXhdO1xuICAgICAgICAvLyBTcGxpdCBpY29uIGNsYXNzZXMgZnJvbSB0aGUgYnV0dG9uLlxuICAgICAgICAvLyBSZWdleCB3aWxsIGRldGVjdCBcImZhXCIsIFwiZmFzXCIsIFwiZmEtc29tZXRoaW5nXCIgYW5kIFwiZmEtc29tZS1pY29uLTFcIiwgYnV0IG5vdCBcImZhbmZhcmVcIi5cbiAgICAgICAgaWYgKGNsYXNzTmFtZVBhcnQubWF0Y2goL15mYShbc3JsYl18KC1bXFx3LV0qKXwkKS8pKSB7XG4gICAgICAgICAgICBpY29uQ2xhc3Nlcy5wdXNoKGNsYXNzTmFtZVBhcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWVQYXJ0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsLnRhYkluZGV4ID0gLTE7XG5cbiAgICBpZiAoaWNvbkNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBDcmVhdGUgaWNvbiBlbGVtZW50IGFuZCBhcHBlbmQgYXMgYSBjaGlsZCB0byB0aGUgYnV0dG9uXG4gICAgICAgIHZhciBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuICAgICAgICBmb3IgKHZhciBpY29uQ2xhc3NJbmRleCA9IDA7IGljb25DbGFzc0luZGV4IDwgaWNvbkNsYXNzZXMubGVuZ3RoOyBpY29uQ2xhc3NJbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgaWNvbkNsYXNzID0gaWNvbkNsYXNzZXNbaWNvbkNsYXNzSW5kZXhdO1xuICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKGljb25DbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoaWNvbik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBjdXN0b20gaWNvbiBtYXJrdXAgc2V0LCB1c2UgdGhhdFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pY29uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSBvcHRpb25zLmljb247XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWN0aW9uICYmIGVuYWJsZUFjdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZWwub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYWN0aW9uKHBhcmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVsLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cub3BlbihvcHRpb25zLmFjdGlvbiwgJ19ibGFuaycpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VwKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcbiAgICBlbC5jbGFzc05hbWUgPSAnc2VwYXJhdG9yJztcbiAgICBlbC5pbm5lckhUTUwgPSAnfCc7XG4gICAgcmV0dXJuIGVsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwKHRpdGxlLCBhY3Rpb24sIHNob3J0Y3V0cykge1xuICAgIHZhciBhY3Rpb25OYW1lO1xuICAgIHZhciB0b29sdGlwID0gdGl0bGU7XG5cbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIGFjdGlvbk5hbWUgPSBnZXRCaW5kaW5nTmFtZShhY3Rpb24pO1xuICAgICAgICBpZiAoc2hvcnRjdXRzW2FjdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICB0b29sdGlwICs9ICcgKCcgKyBmaXhTaG9ydGN1dChzaG9ydGN1dHNbYWN0aW9uTmFtZV0pICsgJyknO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvb2x0aXA7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIG9mIENvZGVNaXJyb3IgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0ZShjbSwgcG9zKSB7XG4gICAgcG9zID0gcG9zIHx8IGNtLmdldEN1cnNvcignc3RhcnQnKTtcbiAgICB2YXIgc3RhdCA9IGNtLmdldFRva2VuQXQocG9zKTtcbiAgICBpZiAoIXN0YXQudHlwZSkgcmV0dXJuIHt9O1xuXG4gICAgdmFyIHR5cGVzID0gc3RhdC50eXBlLnNwbGl0KCcgJyk7XG5cbiAgICB2YXIgcmV0ID0ge30sXG4gICAgICAgIGRhdGEsIHRleHQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhID0gdHlwZXNbaV07XG4gICAgICAgIGlmIChkYXRhID09PSAnc3Ryb25nJykge1xuICAgICAgICAgICAgcmV0LmJvbGQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09ICd2YXJpYWJsZS0yJykge1xuICAgICAgICAgICAgdGV4dCA9IGNtLmdldExpbmUocG9zLmxpbmUpO1xuICAgICAgICAgICAgaWYgKC9eXFxzKlxcZCtcXC5cXHMvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXRbJ29yZGVyZWQtbGlzdCddID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0Wyd1bm9yZGVyZWQtbGlzdCddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSAnYXRvbScpIHtcbiAgICAgICAgICAgIHJldC5xdW90ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ2VtJykge1xuICAgICAgICAgICAgcmV0Lml0YWxpYyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ3F1b3RlJykge1xuICAgICAgICAgICAgcmV0LnF1b3RlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICAgIHJldC5zdHJpa2V0aHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSAnY29tbWVudCcpIHtcbiAgICAgICAgICAgIHJldC5jb2RlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSAnbGluaycgJiYgIXJldC5pbWFnZSkge1xuICAgICAgICAgICAgcmV0LmxpbmsgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09ICdpbWFnZScpIHtcbiAgICAgICAgICAgIHJldC5pbWFnZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5tYXRjaCgvXmhlYWRlcigtWzEtNl0pPyQvKSkge1xuICAgICAgICAgICAgcmV0W2RhdGEucmVwbGFjZSgnaGVhZGVyJywgJ2hlYWRpbmcnKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblxuLy8gU2F2ZWQgb3ZlcmZsb3cgc2V0dGluZ1xudmFyIHNhdmVkX292ZXJmbG93ID0gJyc7XG5cbi8qKlxuICogVG9nZ2xlIGZ1bGwgc2NyZWVuIG9mIHRoZSBlZGl0b3IuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiB0b2dnbGVGdWxsU2NyZWVuKGVkaXRvcikge1xuICAgIC8vIFNldCBmdWxsc2NyZWVuXG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgY20uc2V0T3B0aW9uKCdmdWxsU2NyZWVuJywgIWNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpKTtcblxuXG4gICAgLy8gUHJldmVudCBzY3JvbGxpbmcgb24gYm9keSBkdXJpbmcgZnVsbHNjcmVlbiBhY3RpdmVcbiAgICBpZiAoY20uZ2V0T3B0aW9uKCdmdWxsU2NyZWVuJykpIHtcbiAgICAgICAgc2F2ZWRfb3ZlcmZsb3cgPSBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IHNhdmVkX292ZXJmbG93O1xuICAgIH1cblxuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgc2lkZWJ5c2lkZSA9IHdyYXBwZXIubmV4dFNpYmxpbmc7XG5cbiAgICBpZiAoc2lkZWJ5c2lkZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlJykpIHtcbiAgICAgICAgaWYgKGVkaXRvci5vcHRpb25zLnNpZGVCeVNpZGVGdWxsc2NyZWVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gaWYgc2lkZS1ieS1zaWRlIG5vdC1mdWxsc2NyZWVuIG9rLCBhcHBseSBjbGFzc2VzIGFzIG5lZWRlZFxuICAgICAgICAgICAgdmFyIGVhc3lNREVDb250YWluZXIgPSB3cmFwcGVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKCdmdWxsU2NyZWVuJykpIHtcbiAgICAgICAgICAgICAgICBlYXN5TURFQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ3NpZGVkLS1uby1mdWxsc2NyZWVuJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVhc3lNREVDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnc2lkZWQtLW5vLWZ1bGxzY3JlZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvZ2dsZVNpZGVCeVNpZGUoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlZGl0b3Iub3B0aW9ucy5vblRvZ2dsZUZ1bGxTY3JlZW4pIHtcbiAgICAgICAgZWRpdG9yLm9wdGlvbnMub25Ub2dnbGVGdWxsU2NyZWVuKGNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgb3Igc2V0IG1heEhlaWdodFxuICAgIGlmICh0eXBlb2YgZWRpdG9yLm9wdGlvbnMubWF4SGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKCdmdWxsU2NyZWVuJykpIHtcbiAgICAgICAgICAgIGNtLmdldFNjcm9sbGVyRWxlbWVudCgpLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcbiAgICAgICAgICAgIHNpZGVieXNpZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2hlaWdodCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY20uZ2V0U2Nyb2xsZXJFbGVtZW50KCkuc3R5bGUuaGVpZ2h0ID0gZWRpdG9yLm9wdGlvbnMubWF4SGVpZ2h0O1xuICAgICAgICAgICAgZWRpdG9yLnNldFByZXZpZXdNYXhIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0b29sYmFyIGNsYXNzXG4gICAgZWRpdG9yLnRvb2xiYXJfZGl2LmNsYXNzTGlzdC50b2dnbGUoJ2Z1bGxzY3JlZW4nKTtcblxuICAgIC8vIFVwZGF0ZSB0b29sYmFyIGJ1dHRvblxuICAgIGlmIChlZGl0b3IudG9vbGJhckVsZW1lbnRzICYmIGVkaXRvci50b29sYmFyRWxlbWVudHMuZnVsbHNjcmVlbikge1xuICAgICAgICB2YXIgdG9vbGJhckJ1dHRvbiA9IGVkaXRvci50b29sYmFyRWxlbWVudHMuZnVsbHNjcmVlbjtcbiAgICAgICAgdG9vbGJhckJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGJvbGQuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiB0b2dnbGVCb2xkKGVkaXRvcikge1xuICAgIF90b2dnbGVCbG9jayhlZGl0b3IsICdib2xkJywgZWRpdG9yLm9wdGlvbnMuYmxvY2tTdHlsZXMuYm9sZCk7XG59XG5cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGl0YWxpYy5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUl0YWxpYyhlZGl0b3IpIHtcbiAgICBfdG9nZ2xlQmxvY2soZWRpdG9yLCAnaXRhbGljJywgZWRpdG9yLm9wdGlvbnMuYmxvY2tTdHlsZXMuaXRhbGljKTtcbn1cblxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgc3RyaWtldGhyb3VnaC5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZVN0cmlrZXRocm91Z2goZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUJsb2NrKGVkaXRvciwgJ3N0cmlrZXRocm91Z2gnLCAnfn4nKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGNvZGUgYmxvY2suXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiB0b2dnbGVDb2RlQmxvY2soZWRpdG9yKSB7XG4gICAgdmFyIGZlbmNlQ2hhcnNUb0luc2VydCA9IGVkaXRvci5vcHRpb25zLmJsb2NrU3R5bGVzLmNvZGU7XG5cbiAgICBmdW5jdGlvbiBmZW5jaW5nX2xpbmUobGluZSkge1xuICAgICAgICAvKiByZXR1cm4gdHJ1ZSwgaWYgdGhpcyBpcyBhIGBgYCBvciB+fn4gbGluZSAqL1xuICAgICAgICBpZiAodHlwZW9mIGxpbmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyAnZmVuY2luZ19saW5lKCkgdGFrZXMgYSBcXCdsaW5lXFwnIG9iamVjdCAobm90IGEgbGluZSBudW1iZXIsIG9yIGxpbmUgdGV4dCkuICBHb3Q6ICcgKyB0eXBlb2YgbGluZSArICc6ICcgKyBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lLnN0eWxlcyAmJiBsaW5lLnN0eWxlc1syXSAmJiBsaW5lLnN0eWxlc1syXS5pbmRleE9mKCdmb3JtYXR0aW5nLWNvZGUtYmxvY2snKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5fc3RhdGUodG9rZW4pIHtcbiAgICAgICAgLy8gYmFzZSBnb2VzIGFuIGV4dHJhIGxldmVsIGRlZXAgd2hlbiBtb2RlIGJhY2tkcm9wcyBhcmUgdXNlZCwgZS5nLiBzcGVsbGNoZWNrZXIgb25cbiAgICAgICAgcmV0dXJuIHRva2VuLnN0YXRlLmJhc2UuYmFzZSB8fCB0b2tlbi5zdGF0ZS5iYXNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvZGVfdHlwZShjbSwgbGluZV9udW0sIGxpbmUsIGZpcnN0VG9rLCBsYXN0VG9rKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBcInNpbmdsZVwiLCBcImluZGVudGVkXCIsIFwiZmVuY2VkXCIgb3IgZmFsc2VcbiAgICAgICAgICpcbiAgICAgICAgICogY20gYW5kIGxpbmVfbnVtIGFyZSByZXF1aXJlZC4gIE90aGVycyBhcmUgb3B0aW9uYWwgZm9yIGVmZmljaWVuY3lcbiAgICAgICAgICogICBUbyBjaGVjayBpbiB0aGUgbWlkZGxlIG9mIGEgbGluZSwgcGFzcyBpbiBmaXJzdFRvayB5b3Vyc2VsZi5cbiAgICAgICAgICovXG4gICAgICAgIGxpbmUgPSBsaW5lIHx8IGNtLmdldExpbmVIYW5kbGUobGluZV9udW0pO1xuICAgICAgICBmaXJzdFRvayA9IGZpcnN0VG9rIHx8IGNtLmdldFRva2VuQXQoe1xuICAgICAgICAgICAgbGluZTogbGluZV9udW0sXG4gICAgICAgICAgICBjaDogMSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RUb2sgPSBsYXN0VG9rIHx8ICghIWxpbmUudGV4dCAmJiBjbS5nZXRUb2tlbkF0KHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVfbnVtLFxuICAgICAgICAgICAgY2g6IGxpbmUudGV4dC5sZW5ndGggLSAxLFxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciB0eXBlcyA9IGZpcnN0VG9rLnR5cGUgPyBmaXJzdFRvay50eXBlLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgICAgaWYgKGxhc3RUb2sgJiYgdG9rZW5fc3RhdGUobGFzdFRvaykuaW5kZW50ZWRDb2RlKSB7XG4gICAgICAgICAgICAvLyBoYXZlIHRvIGNoZWNrIGxhc3QgY2hhciwgc2luY2UgZmlyc3QgY2hhcnMgb2YgZmlyc3QgbGluZSBhcmVuXCJ0IG1hcmtlZCBhcyBpbmRlbnRlZFxuICAgICAgICAgICAgcmV0dXJuICdpbmRlbnRlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZXMuaW5kZXhPZignY29tbWVudCcpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gaGFzIHRvIGJlIGFmdGVyIFwiaW5kZW50ZWRcIiBjaGVjaywgc2luY2UgZmlyc3QgY2hhcnMgb2YgZmlyc3QgaW5kZW50ZWQgbGluZSBhcmVuXCJ0IG1hcmtlZCBhcyBzdWNoXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5fc3RhdGUoZmlyc3RUb2spLmZlbmNlZENoYXJzIHx8IHRva2VuX3N0YXRlKGxhc3RUb2spLmZlbmNlZENoYXJzIHx8IGZlbmNpbmdfbGluZShsaW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuICdmZW5jZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdzaW5nbGUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0RmVuY2luZ0F0U2VsZWN0aW9uKGNtLCBjdXJfc3RhcnQsIGN1cl9lbmQsIGZlbmNlQ2hhcnNUb0luc2VydCkge1xuICAgICAgICB2YXIgc3RhcnRfbGluZV9zZWwgPSBjdXJfc3RhcnQubGluZSArIDEsXG4gICAgICAgICAgICBlbmRfbGluZV9zZWwgPSBjdXJfZW5kLmxpbmUgKyAxLFxuICAgICAgICAgICAgc2VsX211bHRpID0gY3VyX3N0YXJ0LmxpbmUgIT09IGN1cl9lbmQubGluZSxcbiAgICAgICAgICAgIHJlcGxfc3RhcnQgPSBmZW5jZUNoYXJzVG9JbnNlcnQgKyAnXFxuJyxcbiAgICAgICAgICAgIHJlcGxfZW5kID0gJ1xcbicgKyBmZW5jZUNoYXJzVG9JbnNlcnQ7XG4gICAgICAgIGlmIChzZWxfbXVsdGkpIHtcbiAgICAgICAgICAgIGVuZF9saW5lX3NlbCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBsYXN0IGNoYXIgaW5jbHVkaW5nIFxcbiBvciBub3RcbiAgICAgICAgaWYgKHNlbF9tdWx0aSAmJiBjdXJfZW5kLmNoID09PSAwKSB7XG4gICAgICAgICAgICByZXBsX2VuZCA9IGZlbmNlQ2hhcnNUb0luc2VydCArICdcXG4nO1xuICAgICAgICAgICAgZW5kX2xpbmVfc2VsLS07XG4gICAgICAgIH1cbiAgICAgICAgX3JlcGxhY2VTZWxlY3Rpb24oY20sIGZhbHNlLCBbcmVwbF9zdGFydCwgcmVwbF9lbmRdKTtcbiAgICAgICAgY20uc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0X2xpbmVfc2VsLFxuICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGxpbmU6IGVuZF9saW5lX3NlbCxcbiAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcixcbiAgICAgICAgY3VyX3N0YXJ0ID0gY20uZ2V0Q3Vyc29yKCdzdGFydCcpLFxuICAgICAgICBjdXJfZW5kID0gY20uZ2V0Q3Vyc29yKCdlbmQnKSxcbiAgICAgICAgdG9rID0gY20uZ2V0VG9rZW5BdCh7XG4gICAgICAgICAgICBsaW5lOiBjdXJfc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNoOiBjdXJfc3RhcnQuY2ggfHwgMSxcbiAgICAgICAgfSksIC8vIGF2b2lkIGNoIDAgd2hpY2ggaXMgYSBjdXJzb3IgcG9zIGJ1dCBub3QgdG9rZW5cbiAgICAgICAgbGluZSA9IGNtLmdldExpbmVIYW5kbGUoY3VyX3N0YXJ0LmxpbmUpLFxuICAgICAgICBpc19jb2RlID0gY29kZV90eXBlKGNtLCBjdXJfc3RhcnQubGluZSwgbGluZSwgdG9rKTtcbiAgICB2YXIgYmxvY2tfc3RhcnQsIGJsb2NrX2VuZCwgbGluZUNvdW50O1xuXG4gICAgaWYgKGlzX2NvZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgIC8vIHNpbWlsYXIgdG8gc29tZSBFYXN5TURFIF90b2dnbGVCbG9jayBsb2dpY1xuICAgICAgICB2YXIgc3RhcnQgPSBsaW5lLnRleHQuc2xpY2UoMCwgY3VyX3N0YXJ0LmNoKS5yZXBsYWNlKCdgJywgJycpLFxuICAgICAgICAgICAgZW5kID0gbGluZS50ZXh0LnNsaWNlKGN1cl9zdGFydC5jaCkucmVwbGFjZSgnYCcsICcnKTtcbiAgICAgICAgY20ucmVwbGFjZVJhbmdlKHN0YXJ0ICsgZW5kLCB7XG4gICAgICAgICAgICBsaW5lOiBjdXJfc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsaW5lOiBjdXJfc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OSxcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cl9zdGFydC5jaC0tO1xuICAgICAgICBpZiAoY3VyX3N0YXJ0ICE9PSBjdXJfZW5kKSB7XG4gICAgICAgICAgICBjdXJfZW5kLmNoLS07XG4gICAgICAgIH1cbiAgICAgICAgY20uc2V0U2VsZWN0aW9uKGN1cl9zdGFydCwgY3VyX2VuZCk7XG4gICAgICAgIGNtLmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmIChpc19jb2RlID09PSAnZmVuY2VkJykge1xuICAgICAgICBpZiAoY3VyX3N0YXJ0LmxpbmUgIT09IGN1cl9lbmQubGluZSB8fCBjdXJfc3RhcnQuY2ggIT09IGN1cl9lbmQuY2gpIHtcbiAgICAgICAgICAgIC8vIHVzZSBzZWxlY3Rpb25cblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgZmVuY2VkIGxpbmUgc28gd2Uga25vdyB3aGF0IHR5cGUgaXQgaXMgKHRpbGRlLCBiYWNrdGlja3MsIG51bWJlciBvZiB0aGVtKVxuICAgICAgICAgICAgZm9yIChibG9ja19zdGFydCA9IGN1cl9zdGFydC5saW5lOyBibG9ja19zdGFydCA+PSAwOyBibG9ja19zdGFydC0tKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGNtLmdldExpbmVIYW5kbGUoYmxvY2tfc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChmZW5jaW5nX2xpbmUobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZlbmNlZFRvayA9IGNtLmdldFRva2VuQXQoe1xuICAgICAgICAgICAgICAgIGxpbmU6IGJsb2NrX3N0YXJ0LFxuICAgICAgICAgICAgICAgIGNoOiAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZmVuY2VfY2hhcnMgPSB0b2tlbl9zdGF0ZShmZW5jZWRUb2spLmZlbmNlZENoYXJzO1xuICAgICAgICAgICAgdmFyIHN0YXJ0X3RleHQsIHN0YXJ0X2xpbmU7XG4gICAgICAgICAgICB2YXIgZW5kX3RleHQsIGVuZF9saW5lO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNlbGVjdGlvbiBnb2luZyB1cCBhZ2FpbnN0IGZlbmNlZCBsaW5lcywgaW4gd2hpY2ggY2FzZSB3ZSBkb24ndCB3YW50IHRvIGFkZCBtb3JlIGZlbmNpbmdcbiAgICAgICAgICAgIGlmIChmZW5jaW5nX2xpbmUoY20uZ2V0TGluZUhhbmRsZShjdXJfc3RhcnQubGluZSkpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRfdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIHN0YXJ0X2xpbmUgPSBjdXJfc3RhcnQubGluZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmVuY2luZ19saW5lKGNtLmdldExpbmVIYW5kbGUoY3VyX3N0YXJ0LmxpbmUgLSAxKSkpIHtcbiAgICAgICAgICAgICAgICBzdGFydF90ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgc3RhcnRfbGluZSA9IGN1cl9zdGFydC5saW5lIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRfdGV4dCA9IGZlbmNlX2NoYXJzICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgc3RhcnRfbGluZSA9IGN1cl9zdGFydC5saW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZlbmNpbmdfbGluZShjbS5nZXRMaW5lSGFuZGxlKGN1cl9lbmQubGluZSkpKSB7XG4gICAgICAgICAgICAgICAgZW5kX3RleHQgPSAnJztcbiAgICAgICAgICAgICAgICBlbmRfbGluZSA9IGN1cl9lbmQubGluZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyX2VuZC5jaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlbmRfbGluZSArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyX2VuZC5jaCAhPT0gMCAmJiBmZW5jaW5nX2xpbmUoY20uZ2V0TGluZUhhbmRsZShjdXJfZW5kLmxpbmUgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICBlbmRfdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIGVuZF9saW5lID0gY3VyX2VuZC5saW5lICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kX3RleHQgPSBmZW5jZV9jaGFycyArICdcXG4nO1xuICAgICAgICAgICAgICAgIGVuZF9saW5lID0gY3VyX2VuZC5saW5lICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJfZW5kLmNoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZnVsbCBsYXN0IGxpbmUgc2VsZWN0ZWQsIHB1dHRpbmcgY3Vyc29yIGF0IGJlZ2lubmluZyBvZiBuZXh0XG4gICAgICAgICAgICAgICAgZW5kX2xpbmUgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5kIGxpbmUgZmlyc3QsIHNvIHRoYXQgbGluZSBudW1iZXJzIGRvbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShlbmRfdGV4dCwge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBlbmRfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBlbmRfbGluZSArIChlbmRfdGV4dCA/IDAgOiAxKSxcbiAgICAgICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKHN0YXJ0X3RleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogc3RhcnRfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBzdGFydF9saW5lICsgKHN0YXJ0X3RleHQgPyAwIDogMSksXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbS5zZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0X2xpbmUgKyAoc3RhcnRfdGV4dCA/IDEgOiAwKSxcbiAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5lOiBlbmRfbGluZSArIChzdGFydF90ZXh0ID8gMSA6IC0xKSxcbiAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIHNlbGVjdGlvbiwgc2VhcmNoIGZvciBlbmRzIG9mIHRoaXMgZmVuY2VkIGJsb2NrXG4gICAgICAgICAgICB2YXIgc2VhcmNoX2Zyb20gPSBjdXJfc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChmZW5jaW5nX2xpbmUoY20uZ2V0TGluZUhhbmRsZShjdXJfc3RhcnQubGluZSkpKSB7IC8vIGdldHMgYSBsaXR0bGUgdHJpY2t5IGlmIGN1cnNvciBpcyByaWdodCBvbiBhIGZlbmNlZCBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKGNvZGVfdHlwZShjbSwgY3VyX3N0YXJ0LmxpbmUgKyAxKSA9PT0gJ2ZlbmNlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tfc3RhcnQgPSBjdXJfc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoX2Zyb20gPSBjdXJfc3RhcnQubGluZSArIDE7IC8vIGZvciBzZWFyY2hpbmcgZm9yIFwiZW5kXCJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBibG9ja19lbmQgPSBjdXJfc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoX2Zyb20gPSBjdXJfc3RhcnQubGluZSAtIDE7IC8vIGZvciBzZWFyY2hpbmcgZm9yIFwic3RhcnRcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja19zdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChibG9ja19zdGFydCA9IHNlYXJjaF9mcm9tOyBibG9ja19zdGFydCA+PSAwOyBibG9ja19zdGFydC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKGJsb2NrX3N0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNpbmdfbGluZShsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tfZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsaW5lQ291bnQgPSBjbS5saW5lQ291bnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGJsb2NrX2VuZCA9IHNlYXJjaF9mcm9tOyBibG9ja19lbmQgPCBsaW5lQ291bnQ7IGJsb2NrX2VuZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKGJsb2NrX2VuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZW5jaW5nX2xpbmUobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJycsIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogYmxvY2tfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogYmxvY2tfc3RhcnQgKyAxLFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJycsIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogYmxvY2tfZW5kIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBibG9ja19lbmQsXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc19jb2RlID09PSAnaW5kZW50ZWQnKSB7XG4gICAgICAgIGlmIChjdXJfc3RhcnQubGluZSAhPT0gY3VyX2VuZC5saW5lIHx8IGN1cl9zdGFydC5jaCAhPT0gY3VyX2VuZC5jaCkge1xuICAgICAgICAgICAgLy8gdXNlIHNlbGVjdGlvblxuICAgICAgICAgICAgYmxvY2tfc3RhcnQgPSBjdXJfc3RhcnQubGluZTtcbiAgICAgICAgICAgIGJsb2NrX2VuZCA9IGN1cl9lbmQubGluZTtcbiAgICAgICAgICAgIGlmIChjdXJfZW5kLmNoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tfZW5kLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBzZWxlY3Rpb24sIHNlYXJjaCBmb3IgZW5kcyBvZiB0aGlzIGluZGVudGVkIGJsb2NrXG4gICAgICAgICAgICBmb3IgKGJsb2NrX3N0YXJ0ID0gY3VyX3N0YXJ0LmxpbmU7IGJsb2NrX3N0YXJ0ID49IDA7IGJsb2NrX3N0YXJ0LS0pIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gY20uZ2V0TGluZUhhbmRsZShibG9ja19zdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dC5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHkgb3IgYWxsIHdoaXRlc3BhY2UgLSBrZWVwIGdvaW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlX3R5cGUoY20sIGJsb2NrX3N0YXJ0LCBsaW5lKSAhPT0gJ2luZGVudGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tfc3RhcnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZUNvdW50ID0gY20ubGluZUNvdW50KCk7XG4gICAgICAgICAgICBmb3IgKGJsb2NrX2VuZCA9IGN1cl9zdGFydC5saW5lOyBibG9ja19lbmQgPCBsaW5lQ291bnQ7IGJsb2NrX2VuZCsrKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGNtLmdldExpbmVIYW5kbGUoYmxvY2tfZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZS50ZXh0Lm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eSBvciBhbGwgd2hpdGVzcGFjZSAtIGtlZXAgZ29pbmdcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVfdHlwZShjbSwgYmxvY2tfZW5kLCBsaW5lKSAhPT0gJ2luZGVudGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tfZW5kIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBhcmUgZ29pbmcgdG8gdW4taW5kZW50IGJhc2VkIG9uIGEgc2VsZWN0ZWQgc2V0IG9mIGxpbmVzLCBhbmQgdGhlIG5leHQgbGluZSBpcyBpbmRlbnRlZCB0b28sIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gaW5zZXJ0IGEgYmxhbmsgbGluZSBzbyB0aGF0IHRoZSBuZXh0IGxpbmUocykgY29udGludWUgdG8gYmUgaW5kZW50ZWQgY29kZVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gY20uZ2V0TGluZUhhbmRsZShibG9ja19lbmQgKyAxKSxcbiAgICAgICAgICAgIG5leHRfbGluZV9sYXN0X3RvayA9IG5leHRfbGluZSAmJiBjbS5nZXRUb2tlbkF0KHtcbiAgICAgICAgICAgICAgICBsaW5lOiBibG9ja19lbmQgKyAxLFxuICAgICAgICAgICAgICAgIGNoOiBuZXh0X2xpbmUudGV4dC5sZW5ndGggLSAxLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXh0X2xpbmVfaW5kZW50ZWQgPSBuZXh0X2xpbmVfbGFzdF90b2sgJiYgdG9rZW5fc3RhdGUobmV4dF9saW5lX2xhc3RfdG9rKS5pbmRlbnRlZENvZGU7XG4gICAgICAgIGlmIChuZXh0X2xpbmVfaW5kZW50ZWQpIHtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSgnXFxuJywge1xuICAgICAgICAgICAgICAgIGxpbmU6IGJsb2NrX2VuZCArIDEsXG4gICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBibG9ja19zdGFydDsgaSA8PSBibG9ja19lbmQ7IGkrKykge1xuICAgICAgICAgICAgY20uaW5kZW50TGluZShpLCAnc3VidHJhY3QnKTsgLy8gVE9ETzogdGhpcyBkb2Vzbid0IGdldCB0cmFja2VkIGluIHRoZSBoaXN0b3J5LCBzbyBjYW4ndCBiZSB1bmRvbmUgOihcbiAgICAgICAgfVxuICAgICAgICBjbS5mb2N1cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluc2VydCBjb2RlIGZvcm1hdHRpbmdcbiAgICAgICAgdmFyIG5vX3NlbF9hbmRfc3RhcnRpbmdfb2ZfbGluZSA9IChjdXJfc3RhcnQubGluZSA9PT0gY3VyX2VuZC5saW5lICYmIGN1cl9zdGFydC5jaCA9PT0gY3VyX2VuZC5jaCAmJiBjdXJfc3RhcnQuY2ggPT09IDApO1xuICAgICAgICB2YXIgc2VsX211bHRpID0gY3VyX3N0YXJ0LmxpbmUgIT09IGN1cl9lbmQubGluZTtcbiAgICAgICAgaWYgKG5vX3NlbF9hbmRfc3RhcnRpbmdfb2ZfbGluZSB8fCBzZWxfbXVsdGkpIHtcbiAgICAgICAgICAgIGluc2VydEZlbmNpbmdBdFNlbGVjdGlvbihjbSwgY3VyX3N0YXJ0LCBjdXJfZW5kLCBmZW5jZUNoYXJzVG9JbnNlcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3JlcGxhY2VTZWxlY3Rpb24oY20sIGZhbHNlLCBbJ2AnLCAnYCddKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGJsb2NrcXVvdGUuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUJsb2NrcXVvdGUoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUxpbmUoZWRpdG9yLmNvZGVtaXJyb3IsICdxdW90ZScpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaGVhZGluZyBzaXplOiBub3JtYWwgLT4gaDEgLT4gaDIgLT4gaDMgLT4gaDQgLT4gaDUgLT4gaDYgLT4gbm9ybWFsXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRpbmdTbWFsbGVyKGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCAnc21hbGxlcicpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaGVhZGluZyBzaXplOiBub3JtYWwgLT4gaDYgLT4gaDUgLT4gaDQgLT4gaDMgLT4gaDIgLT4gaDEgLT4gbm9ybWFsXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRpbmdCaWdnZXIoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUhlYWRpbmcoZWRpdG9yLmNvZGVtaXJyb3IsICdiaWdnZXInKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZSAxXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRpbmcxKGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCB1bmRlZmluZWQsIDEpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaGVhZGluZyBzaXplIDJcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGluZzIoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUhlYWRpbmcoZWRpdG9yLmNvZGVtaXJyb3IsIHVuZGVmaW5lZCwgMik7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBoZWFkaW5nIHNpemUgM1xuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nMyhlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgdW5kZWZpbmVkLCAzKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZSA0XG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRpbmc0KGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCB1bmRlZmluZWQsIDQpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaGVhZGluZyBzaXplIDVcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGluZzUoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUhlYWRpbmcoZWRpdG9yLmNvZGVtaXJyb3IsIHVuZGVmaW5lZCwgNSk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBoZWFkaW5nIHNpemUgNlxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nNihlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgdW5kZWZpbmVkLCA2KTtcbn1cblxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgdWwuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZVVub3JkZXJlZExpc3QoZWRpdG9yKSB7XG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG5cbiAgICB2YXIgbGlzdFN0eWxlID0gJyonOyAvLyBEZWZhdWx0XG4gICAgaWYgKFsnLScsICcrJywgJyonXS5pbmNsdWRlcyhlZGl0b3Iub3B0aW9ucy51bm9yZGVyZWRMaXN0U3R5bGUpKSB7XG4gICAgICAgIGxpc3RTdHlsZSA9IGVkaXRvci5vcHRpb25zLnVub3JkZXJlZExpc3RTdHlsZTtcbiAgICB9XG5cbiAgICBfdG9nZ2xlTGluZShjbSwgJ3Vub3JkZXJlZC1saXN0JywgbGlzdFN0eWxlKTtcbn1cblxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgb2wuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZU9yZGVyZWRMaXN0KGVkaXRvcikge1xuICAgIF90b2dnbGVMaW5lKGVkaXRvci5jb2RlbWlycm9yLCAnb3JkZXJlZC1saXN0Jyk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciBjbGVhbiBibG9jayAocmVtb3ZlIGhlYWRsaW5lLCBsaXN0LCBibG9ja3F1b3RlIGNvZGUsIG1hcmtlcnMpXG4gKi9cbmZ1bmN0aW9uIGNsZWFuQmxvY2soZWRpdG9yKSB7XG4gICAgX2NsZWFuQmxvY2soZWRpdG9yLmNvZGVtaXJyb3IpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgZHJhd2luZyBhIGxpbmsuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiBkcmF3TGluayhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGVkaXRvci5vcHRpb25zO1xuICAgIHZhciB1cmwgPSAnaHR0cHM6Ly8nO1xuICAgIGlmIChvcHRpb25zLnByb21wdFVSTHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHByb21wdChvcHRpb25zLnByb21wdFRleHRzLmxpbmssIHVybCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gZXNjYXBlUHJvbXB0VVJMKHJlc3VsdCk7XG4gICAgfVxuICAgIF90b2dnbGVMaW5rKGVkaXRvciwgJ2xpbmsnLCBvcHRpb25zLmluc2VydFRleHRzLmxpbmssIHVybCk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciBkcmF3aW5nIGFuIGltZy5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIGRyYXdJbWFnZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGVkaXRvci5vcHRpb25zO1xuICAgIHZhciB1cmwgPSAnaHR0cHM6Ly8nO1xuICAgIGlmIChvcHRpb25zLnByb21wdFVSTHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHByb21wdChvcHRpb25zLnByb21wdFRleHRzLmltYWdlLCB1cmwpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IGVzY2FwZVByb21wdFVSTChyZXN1bHQpO1xuICAgIH1cbiAgICBfdG9nZ2xlTGluayhlZGl0b3IsICdpbWFnZScsIG9wdGlvbnMuaW5zZXJ0VGV4dHMuaW1hZ2UsIHVybCk7XG59XG5cbi8qKlxuICogRW5jb2RlIGFuZCBlc2NhcGUgVVJMcyB0byBwcmV2ZW50IGJyZWFraW5nIHVwIHJlbmRlcmVkIE1hcmtkb3duIGxpbmtzLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsIG9mIHRoZSBsaW5rIG9yIGltYWdlXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVByb21wdFVSTCh1cmwpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJKHVybCkucmVwbGFjZSgvKFtcXFxcKCldKS9nLCAnXFxcXCQxJyk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciBvcGVuaW5nIHRoZSBicm93c2UtZmlsZSB3aW5kb3cgdG8gdXBsb2FkIGFuIGltYWdlIHRvIGEgc2VydmVyLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3IgVGhlIEVhc3lNREUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGRyYXdVcGxvYWRlZEltYWdlKGVkaXRvcikge1xuICAgIC8vIFRPRE86IERyYXcgdGhlIGltYWdlIHRlbXBsYXRlIHdpdGggYSBmYWtlIHVybD8gaWU6ICchW10oaW1wb3J0aW5nIGZvby5wbmcuLi4pJ1xuICAgIGVkaXRvci5vcGVuQnJvd3NlRmlsZVdpbmRvdygpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBleGVjdXRlZCBhZnRlciBhbiBpbWFnZSBoYXZlIGJlZW4gc3VjY2Vzc2Z1bGx5IGltcG9ydGVkIG9uIHRoZSBzZXJ2ZXIuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvciBUaGUgRWFzeU1ERSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCBvZiB0aGUgdXBsb2FkZWQgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJJbWFnZVVwbG9hZGVkKGVkaXRvciwgdXJsKSB7XG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgdmFyIHN0YXQgPSBnZXRTdGF0ZShjbSk7XG4gICAgdmFyIG9wdGlvbnMgPSBlZGl0b3Iub3B0aW9ucztcbiAgICB2YXIgaW1hZ2VOYW1lID0gdXJsLnN1YnN0cih1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgIHZhciBleHQgPSBpbWFnZU5hbWUuc3Vic3RyaW5nKGltYWdlTmFtZS5sYXN0SW5kZXhPZignLicpICsgMSkucmVwbGFjZSgvXFw/LiokLywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBDaGVjayBpZiBtZWRpYSBpcyBhbiBpbWFnZVxuICAgIGlmIChbJ3BuZycsICdqcGcnLCAnanBlZycsICdnaWYnLCAnc3ZnJywgJ2FwbmcnLCAnYXZpZicsICd3ZWJwJ10uaW5jbHVkZXMoZXh0KSkge1xuICAgICAgICBfcmVwbGFjZVNlbGVjdGlvbihjbSwgc3RhdC5pbWFnZSwgb3B0aW9ucy5pbnNlcnRUZXh0cy51cGxvYWRlZEltYWdlLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0X2xpbmsgPSBvcHRpb25zLmluc2VydFRleHRzLmxpbms7XG4gICAgICAgIHRleHRfbGlua1swXSA9ICdbJyArIGltYWdlTmFtZTtcbiAgICAgICAgX3JlcGxhY2VTZWxlY3Rpb24oY20sIHN0YXQubGluaywgdGV4dF9saW5rLCB1cmwpO1xuICAgIH1cblxuICAgIC8vIHNob3cgdXBsb2FkZWQgaW1hZ2UgZmlsZW5hbWUgZm9yIDEwMDBtc1xuICAgIGVkaXRvci51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIGVkaXRvci5vcHRpb25zLmltYWdlVGV4dHMuc2JPblVwbG9hZGVkLnJlcGxhY2UoJyNpbWFnZV9uYW1lIycsIGltYWdlTmFtZSkpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBlZGl0b3IudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBlZGl0b3Iub3B0aW9ucy5pbWFnZVRleHRzLnNiSW5pdCk7XG4gICAgfSwgMTAwMCk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciBkcmF3aW5nIGEgdGFibGUuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiBkcmF3VGFibGUoZWRpdG9yKSB7XG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgdmFyIHN0YXQgPSBnZXRTdGF0ZShjbSk7XG4gICAgdmFyIG9wdGlvbnMgPSBlZGl0b3Iub3B0aW9ucztcbiAgICBfcmVwbGFjZVNlbGVjdGlvbihjbSwgc3RhdC50YWJsZSwgb3B0aW9ucy5pbnNlcnRUZXh0cy50YWJsZSk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciBkcmF3aW5nIGEgaG9yaXpvbnRhbCBydWxlLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gZHJhd0hvcml6b250YWxSdWxlKGVkaXRvcikge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIHZhciBzdGF0ID0gZ2V0U3RhdGUoY20pO1xuICAgIHZhciBvcHRpb25zID0gZWRpdG9yLm9wdGlvbnM7XG4gICAgX3JlcGxhY2VTZWxlY3Rpb24oY20sIHN0YXQuaW1hZ2UsIG9wdGlvbnMuaW5zZXJ0VGV4dHMuaG9yaXpvbnRhbFJ1bGUpO1xufVxuXG5cbi8qKlxuICogVW5kbyBhY3Rpb24uXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiB1bmRvKGVkaXRvcikge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIGNtLnVuZG8oKTtcbiAgICBjbS5mb2N1cygpO1xufVxuXG5cbi8qKlxuICogUmVkbyBhY3Rpb24uXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiByZWRvKGVkaXRvcikge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIGNtLnJlZG8oKTtcbiAgICBjbS5mb2N1cygpO1xufVxuXG5cbi8qKlxuICogVG9nZ2xlIHNpZGUgYnkgc2lkZSBwcmV2aWV3XG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiB0b2dnbGVTaWRlQnlTaWRlKGVkaXRvcikge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgcHJldmlldyA9IHdyYXBwZXIubmV4dFNpYmxpbmc7XG4gICAgdmFyIHRvb2xiYXJCdXR0b24gPSBlZGl0b3IudG9vbGJhckVsZW1lbnRzICYmIGVkaXRvci50b29sYmFyRWxlbWVudHNbJ3NpZGUtYnktc2lkZSddO1xuICAgIHZhciB1c2VTaWRlQnlTaWRlTGlzdGVuZXIgPSBmYWxzZTtcblxuICAgIHZhciBlYXN5TURFQ29udGFpbmVyID0gd3JhcHBlci5wYXJlbnROb2RlO1xuXG4gICAgaWYgKHByZXZpZXcuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUtc2lkZScpKSB7XG4gICAgICAgIGlmIChlZGl0b3Iub3B0aW9ucy5zaWRlQnlTaWRlRnVsbHNjcmVlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGlmIHNpZGUtYnktc2lkZSBub3QtZnVsbHNjcmVlbiBvaywgcmVtb3ZlIGNsYXNzZXMgd2hlbiBoaWRpbmcgc2lkZVxuICAgICAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdzaWRlZC0tbm8tZnVsbHNjcmVlbicpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpZXcuY2xhc3NMaXN0LnJlbW92ZSgnZWRpdG9yLXByZXZpZXctYWN0aXZlLXNpZGUnKTtcbiAgICAgICAgaWYgKHRvb2xiYXJCdXR0b24pIHRvb2xiYXJCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnQ29kZU1pcnJvci1zaWRlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIHByZXZpZXcgYnV0dG9uIGlzIGNsaWNrZWQgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICAgICAgICAvLyBnaXZlIHNvbWUgdGltZSBmb3IgdGhlIHRyYW5zaXRpb24gZnJvbSBlZGl0b3IuY3NzIHRvIGZpcmUgYW5kIHRoZSB2aWV3IHRvIHNsaWRlIGZyb20gcmlnaHQgdG8gbGVmdCxcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBqdXN0IGFwcGVhcmluZy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvci5vcHRpb25zLnNpZGVCeVNpZGVGdWxsc2NyZWVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBzaWRlLWJ5LXNpZGUgbm90LWZ1bGxzY3JlZW4gb2ssIGFkZCBjbGFzc2VzIHdoZW4gbm90IGZ1bGxzY3JlZW4gYW5kIHNob3dpbmcgc2lkZVxuICAgICAgICAgICAgICAgICAgICBlYXN5TURFQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3NpZGVkLS1uby1mdWxsc2NyZWVuJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlRnVsbFNjcmVlbihlZGl0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpZXcuY2xhc3NMaXN0LmFkZCgnZWRpdG9yLXByZXZpZXctYWN0aXZlLXNpZGUnKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIGlmICh0b29sYmFyQnV0dG9uKSB0b29sYmFyQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ0NvZGVNaXJyb3Itc2lkZWQnKTtcbiAgICAgICAgdXNlU2lkZUJ5U2lkZUxpc3RlbmVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBIaWRlIG5vcm1hbCBwcmV2aWV3IGlmIGFjdGl2ZVxuICAgIHZhciBwcmV2aWV3Tm9ybWFsID0gd3JhcHBlci5sYXN0Q2hpbGQ7XG4gICAgaWYgKHByZXZpZXdOb3JtYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKSkge1xuICAgICAgICBwcmV2aWV3Tm9ybWFsLmNsYXNzTGlzdC5yZW1vdmUoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpO1xuICAgICAgICB2YXIgdG9vbGJhciA9IGVkaXRvci50b29sYmFyRWxlbWVudHMucHJldmlldztcbiAgICAgICAgdmFyIHRvb2xiYXJfZGl2ID0gZWRpdG9yLnRvb2xiYXJfZGl2O1xuICAgICAgICB0b29sYmFyLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICB0b29sYmFyX2Rpdi5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZC1mb3ItcHJldmlldycpO1xuICAgIH1cblxuICAgIHZhciBzaWRlQnlTaWRlUmVuZGVyaW5nRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGVkaXRvci5vcHRpb25zLnByZXZpZXdSZW5kZXIoZWRpdG9yLnZhbHVlKCksIHByZXZpZXcpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJldmlldy5pbm5lckhUTUwgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWNtLnNpZGVCeVNpZGVSZW5kZXJpbmdGdW5jdGlvbikge1xuICAgICAgICBjbS5zaWRlQnlTaWRlUmVuZGVyaW5nRnVuY3Rpb24gPSBzaWRlQnlTaWRlUmVuZGVyaW5nRnVuY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKHVzZVNpZGVCeVNpZGVMaXN0ZW5lcikge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBlZGl0b3Iub3B0aW9ucy5wcmV2aWV3UmVuZGVyKGVkaXRvci52YWx1ZSgpLCBwcmV2aWV3KTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByZXZpZXcuaW5uZXJIVE1MID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY20ub24oJ3VwZGF0ZScsIGNtLnNpZGVCeVNpZGVSZW5kZXJpbmdGdW5jdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY20ub2ZmKCd1cGRhdGUnLCBjbS5zaWRlQnlTaWRlUmVuZGVyaW5nRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIC8vIFJlZnJlc2ggdG8gZml4IHNlbGVjdGlvbiBiZWluZyBvZmYgKCMzMDkpXG4gICAgY20ucmVmcmVzaCgpO1xufVxuXG5cbi8qKlxuICogUHJldmlldyBhY3Rpb24uXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiB0b2dnbGVQcmV2aWV3KGVkaXRvcikge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgdG9vbGJhcl9kaXYgPSBlZGl0b3IudG9vbGJhcl9kaXY7XG4gICAgdmFyIHRvb2xiYXIgPSBlZGl0b3Iub3B0aW9ucy50b29sYmFyID8gZWRpdG9yLnRvb2xiYXJFbGVtZW50cy5wcmV2aWV3IDogZmFsc2U7XG4gICAgdmFyIHByZXZpZXcgPSB3cmFwcGVyLmxhc3RDaGlsZDtcblxuICAgIC8vIFR1cm4gb2ZmIHNpZGUgYnkgc2lkZSBpZiBuZWVkZWRcbiAgICB2YXIgc2lkZWJ5c2lkZSA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCkubmV4dFNpYmxpbmc7XG4gICAgaWYgKHNpZGVieXNpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUtc2lkZScpKVxuICAgICAgICB0b2dnbGVTaWRlQnlTaWRlKGVkaXRvcik7XG5cbiAgICBpZiAoIXByZXZpZXcgfHwgIXByZXZpZXcuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1mdWxsJykpIHtcblxuICAgICAgICBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHByZXZpZXcuY2xhc3NOYW1lID0gJ2VkaXRvci1wcmV2aWV3LWZ1bGwnO1xuXG4gICAgICAgIGlmIChlZGl0b3Iub3B0aW9ucy5wcmV2aWV3Q2xhc3MpIHtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWRpdG9yLm9wdGlvbnMucHJldmlld0NsYXNzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRpdG9yLm9wdGlvbnMucHJldmlld0NsYXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpZXcuY2xhc3NMaXN0LmFkZChlZGl0b3Iub3B0aW9ucy5wcmV2aWV3Q2xhc3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZWRpdG9yLm9wdGlvbnMucHJldmlld0NsYXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHByZXZpZXcuY2xhc3NMaXN0LmFkZChlZGl0b3Iub3B0aW9ucy5wcmV2aWV3Q2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChwcmV2aWV3KTtcbiAgICB9XG5cbiAgICBpZiAocHJldmlldy5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpKSB7XG4gICAgICAgIHByZXZpZXcuY2xhc3NMaXN0LnJlbW92ZSgnZWRpdG9yLXByZXZpZXctYWN0aXZlJyk7XG4gICAgICAgIGlmICh0b29sYmFyKSB7XG4gICAgICAgICAgICB0b29sYmFyLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgdG9vbGJhcl9kaXYuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQtZm9yLXByZXZpZXcnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIHByZXZpZXcgYnV0dG9uIGlzIGNsaWNrZWQgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICAgICAgICAvLyBnaXZlIHNvbWUgdGltZSBmb3IgdGhlIHRyYW5zaXRpb24gZnJvbSBlZGl0b3IuY3NzIHRvIGZpcmUgYW5kIHRoZSB2aWV3IHRvIHNsaWRlIGZyb20gcmlnaHQgdG8gbGVmdCxcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBqdXN0IGFwcGVhcmluZy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5hZGQoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpO1xuICAgICAgICB9LCAxKTtcbiAgICAgICAgaWYgKHRvb2xiYXIpIHtcbiAgICAgICAgICAgIHRvb2xiYXIuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICB0b29sYmFyX2Rpdi5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZC1mb3ItcHJldmlldycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpZXdfcmVzdWx0ID0gZWRpdG9yLm9wdGlvbnMucHJldmlld1JlbmRlcihlZGl0b3IudmFsdWUoKSwgcHJldmlldyk7XG4gICAgaWYgKHByZXZpZXdfcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIHByZXZpZXcuaW5uZXJIVE1MID0gcHJldmlld19yZXN1bHQ7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBhY3RpdmUsIHN0YXJ0RW5kLCB1cmwpIHtcbiAgICBpZiAoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5sYXN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHRleHQ7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRFbmRbMF07XG4gICAgdmFyIGVuZCA9IHN0YXJ0RW5kWzFdO1xuICAgIHZhciBzdGFydFBvaW50ID0ge30sXG4gICAgICAgIGVuZFBvaW50ID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihzdGFydFBvaW50LCBjbS5nZXRDdXJzb3IoJ3N0YXJ0JykpO1xuICAgIE9iamVjdC5hc3NpZ24oZW5kUG9pbnQsIGNtLmdldEN1cnNvcignZW5kJykpO1xuICAgIGlmICh1cmwpIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKCcjdXJsIycsIHVybCk7ICAvLyB1cmwgaXMgaW4gc3RhcnQgZm9yIHVwbG9hZC1pbWFnZVxuICAgICAgICBlbmQgPSBlbmQucmVwbGFjZSgnI3VybCMnLCB1cmwpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIHRleHQgPSBjbS5nZXRMaW5lKHN0YXJ0UG9pbnQubGluZSk7XG4gICAgICAgIHN0YXJ0ID0gdGV4dC5zbGljZSgwLCBzdGFydFBvaW50LmNoKTtcbiAgICAgICAgZW5kID0gdGV4dC5zbGljZShzdGFydFBvaW50LmNoKTtcbiAgICAgICAgY20ucmVwbGFjZVJhbmdlKHN0YXJ0ICsgZW5kLCB7XG4gICAgICAgICAgICBsaW5lOiBzdGFydFBvaW50LmxpbmUsXG4gICAgICAgICAgICBjaDogMCxcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHN0YXJ0ICsgdGV4dCArIGVuZCk7XG5cbiAgICAgICAgc3RhcnRQb2ludC5jaCArPSBzdGFydC5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFydFBvaW50ICE9PSBlbmRQb2ludCkge1xuICAgICAgICAgICAgZW5kUG9pbnQuY2ggKz0gc3RhcnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNtLnNldFNlbGVjdGlvbihzdGFydFBvaW50LCBlbmRQb2ludCk7XG4gICAgY20uZm9jdXMoKTtcbn1cblxuXG5mdW5jdGlvbiBfdG9nZ2xlSGVhZGluZyhjbSwgZGlyZWN0aW9uLCBzaXplKSB7XG4gICAgaWYgKGNtLmdldFdyYXBwZXJFbGVtZW50KCkubGFzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJykpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBzdGFydFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdzdGFydCcpO1xuICAgIHZhciBlbmRQb2ludCA9IGNtLmdldEN1cnNvcignZW5kJyk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0UG9pbnQubGluZTsgaSA8PSBlbmRQb2ludC5saW5lOyBpKyspIHtcbiAgICAgICAgKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGNtLmdldExpbmUoaSk7XG4gICAgICAgICAgICB2YXIgY3VyckhlYWRpbmdMZXZlbCA9IHRleHQuc2VhcmNoKC9bXiNdLyk7XG5cbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJySGVhZGluZ0xldmVsIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSAnYmlnZ2VyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcjIyMjIyMgJyArIHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyMgJyArIHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJIZWFkaW5nTGV2ZWwgPT0gNiAmJiBkaXJlY3Rpb24gPT0gJ3NtYWxsZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cig3KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJIZWFkaW5nTGV2ZWwgPT0gMSAmJiBkaXJlY3Rpb24gPT0gJ2JpZ2dlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKDIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gJ2JpZ2dlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSAnIycgKyB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckhlYWRpbmdMZXZlbCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSAnIycucmVwZWF0KHNpemUpICsgJyAnICsgdGV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJIZWFkaW5nTGV2ZWwgPT0gc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHIoY3VyckhlYWRpbmdMZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSAnIycucmVwZWF0KHNpemUpICsgJyAnICsgdGV4dC5zdWJzdHIoY3VyckhlYWRpbmdMZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKHRleHQsIHtcbiAgICAgICAgICAgICAgICBsaW5lOiBpLFxuICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbmU6IGksXG4gICAgICAgICAgICAgICAgY2g6IDk5OTk5OTk5OTk5OTk5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKGkpO1xuICAgIH1cbiAgICBjbS5mb2N1cygpO1xufVxuXG5cbmZ1bmN0aW9uIF90b2dnbGVMaW5lKGNtLCBuYW1lLCBsaXN0c3R5bGUpIHtcbiAgICBpZiAoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5sYXN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIGxpc3RSZWdleHAgPSAvXihcXHMqKShcXCp8LXxcXCt8XFxkKlxcLikoXFxzKykvO1xuICAgIHZhciB3aGl0ZXNwYWNlc1JlZ2V4cCA9IC9eXFxzKi87XG5cbiAgICB2YXIgc3RhdCA9IGdldFN0YXRlKGNtKTtcbiAgICB2YXIgc3RhcnRQb2ludCA9IGNtLmdldEN1cnNvcignc3RhcnQnKTtcbiAgICB2YXIgZW5kUG9pbnQgPSBjbS5nZXRDdXJzb3IoJ2VuZCcpO1xuICAgIHZhciByZXBsID0ge1xuICAgICAgICAncXVvdGUnOiAvXihcXHMqKT5cXHMrLyxcbiAgICAgICAgJ3Vub3JkZXJlZC1saXN0JzogbGlzdFJlZ2V4cCxcbiAgICAgICAgJ29yZGVyZWQtbGlzdCc6IGxpc3RSZWdleHAsXG4gICAgfTtcblxuICAgIHZhciBfZ2V0Q2hhciA9IGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgICAgICAncXVvdGUnOiAnPicsXG4gICAgICAgICAgICAndW5vcmRlcmVkLWxpc3QnOiBsaXN0c3R5bGUsXG4gICAgICAgICAgICAnb3JkZXJlZC1saXN0JzogJyUlaS4nLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBtYXBbbmFtZV0ucmVwbGFjZSgnJSVpJywgaSk7XG4gICAgfTtcblxuICAgIHZhciBfY2hlY2tDaGFyID0gZnVuY3Rpb24gKG5hbWUsIGNoYXIpIHtcbiAgICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgICAgICdxdW90ZSc6ICc+JyxcbiAgICAgICAgICAgICd1bm9yZGVyZWQtbGlzdCc6ICdcXFxcJyArIGxpc3RzdHlsZSxcbiAgICAgICAgICAgICdvcmRlcmVkLWxpc3QnOiAnXFxcXGQrLicsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBydCA9IG5ldyBSZWdFeHAobWFwW25hbWVdKTtcblxuICAgICAgICByZXR1cm4gY2hhciAmJiBydC50ZXN0KGNoYXIpO1xuICAgIH07XG5cbiAgICB2YXIgX3RvZ2dsZSA9IGZ1bmN0aW9uIChuYW1lLCB0ZXh0LCB1bnRvZ2dsZU9ubHkpIHtcbiAgICAgICAgdmFyIGFyciA9IGxpc3RSZWdleHAuZXhlYyh0ZXh0KTtcbiAgICAgICAgdmFyIGNoYXIgPSBfZ2V0Q2hhcihuYW1lLCBsaW5lKTtcbiAgICAgICAgaWYgKGFyciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKF9jaGVja0NoYXIobmFtZSwgYXJyWzJdKSkge1xuICAgICAgICAgICAgICAgIGNoYXIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgPSBhcnJbMV0gKyBjaGFyICsgYXJyWzNdICsgdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VzUmVnZXhwLCAnJykucmVwbGFjZShyZXBsW25hbWVdLCAnJDEnKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bnRvZ2dsZU9ubHkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRleHQgPSBjaGFyICsgJyAnICsgdGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgdmFyIGxpbmUgPSAxO1xuICAgIGZvciAodmFyIGkgPSBzdGFydFBvaW50LmxpbmU7IGkgPD0gZW5kUG9pbnQubGluZTsgaSsrKSB7XG4gICAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBjbS5nZXRMaW5lKGkpO1xuICAgICAgICAgICAgaWYgKHN0YXRbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlcGxbbmFtZV0sICckMScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSB0b2dnbGluZyB1bm9yZGVyZWQtbGlzdCBmb3JtYXR0aW5nLCBjaGVjayBpZiB0aGUgY3VycmVudCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gaXMgcGFydCBvZiBhbiBvcmRlcmVkLWxpc3QsIGFuZCBpZiBzbywgdW50b2dnbGUgdGhhdCBmaXJzdC5cbiAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vSW9uYXJ1L2Vhc3ktbWFya2Rvd24tZWRpdG9yL2lzc3Vlcy85MlxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09ICd1bm9yZGVyZWQtbGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IF90b2dnbGUoJ29yZGVyZWQtbGlzdCcsIHRleHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0ID0gX3RvZ2dsZShuYW1lLCB0ZXh0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbGluZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKHRleHQsIHtcbiAgICAgICAgICAgICAgICBsaW5lOiBpLFxuICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbmU6IGksXG4gICAgICAgICAgICAgICAgY2g6IDk5OTk5OTk5OTk5OTk5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKGkpO1xuICAgIH1cbiAgICBjbS5mb2N1cygpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKiBAcGFyYW0geydsaW5rJyB8ICdpbWFnZSd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydEVuZFxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICovXG5mdW5jdGlvbiBfdG9nZ2xlTGluayhlZGl0b3IsIHR5cGUsIHN0YXJ0RW5kLCB1cmwpIHtcbiAgICBpZiAoIWVkaXRvci5jb2RlbWlycm9yIHx8IGVkaXRvci5pc1ByZXZpZXdBY3RpdmUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgdmFyIHN0YXQgPSBnZXRTdGF0ZShjbSk7XG4gICAgdmFyIGFjdGl2ZSA9IHN0YXRbdHlwZV07XG4gICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgX3JlcGxhY2VTZWxlY3Rpb24oY20sIGFjdGl2ZSwgc3RhcnRFbmQsIHVybCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRQb2ludCA9IGNtLmdldEN1cnNvcignc3RhcnQnKTtcbiAgICB2YXIgZW5kUG9pbnQgPSBjbS5nZXRDdXJzb3IoJ2VuZCcpO1xuICAgIHZhciB0ZXh0ID0gY20uZ2V0TGluZShzdGFydFBvaW50LmxpbmUpO1xuICAgIHZhciBzdGFydCA9IHRleHQuc2xpY2UoMCwgc3RhcnRQb2ludC5jaCk7XG4gICAgdmFyIGVuZCA9IHRleHQuc2xpY2Uoc3RhcnRQb2ludC5jaCk7XG5cbiAgICBpZiAodHlwZSA9PSAnbGluaycpIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC8oLiopW14hXVxcWy8sICckMScpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnaW1hZ2UnKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvKC4qKSFcXFskLywgJyQxJyk7XG4gICAgfVxuICAgIGVuZCA9IGVuZC5yZXBsYWNlKC9dXFwoLio/XFwpLywgJycpO1xuXG4gICAgY20ucmVwbGFjZVJhbmdlKHN0YXJ0ICsgZW5kLCB7XG4gICAgICAgIGxpbmU6IHN0YXJ0UG9pbnQubGluZSxcbiAgICAgICAgY2g6IDAsXG4gICAgfSwge1xuICAgICAgICBsaW5lOiBzdGFydFBvaW50LmxpbmUsXG4gICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OSxcbiAgICB9KTtcblxuICAgIHN0YXJ0UG9pbnQuY2ggLT0gc3RhcnRFbmRbMF0ubGVuZ3RoO1xuICAgIGlmIChzdGFydFBvaW50ICE9PSBlbmRQb2ludCkge1xuICAgICAgICBlbmRQb2ludC5jaCAtPSBzdGFydEVuZFswXS5sZW5ndGg7XG4gICAgfVxuICAgIGNtLnNldFNlbGVjdGlvbihzdGFydFBvaW50LCBlbmRQb2ludCk7XG4gICAgY20uZm9jdXMoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiBfdG9nZ2xlQmxvY2soZWRpdG9yLCB0eXBlLCBzdGFydF9jaGFycywgZW5kX2NoYXJzKSB7XG4gICAgaWYgKCFlZGl0b3IuY29kZW1pcnJvciB8fCBlZGl0b3IuaXNQcmV2aWV3QWN0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVuZF9jaGFycyA9ICh0eXBlb2YgZW5kX2NoYXJzID09PSAndW5kZWZpbmVkJykgPyBzdGFydF9jaGFycyA6IGVuZF9jaGFycztcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICB2YXIgc3RhdCA9IGdldFN0YXRlKGNtKTtcblxuICAgIHZhciB0ZXh0O1xuICAgIHZhciBzdGFydCA9IHN0YXJ0X2NoYXJzO1xuICAgIHZhciBlbmQgPSBlbmRfY2hhcnM7XG5cbiAgICB2YXIgc3RhcnRQb2ludCA9IGNtLmdldEN1cnNvcignc3RhcnQnKTtcbiAgICB2YXIgZW5kUG9pbnQgPSBjbS5nZXRDdXJzb3IoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRbdHlwZV0pIHtcbiAgICAgICAgdGV4dCA9IGNtLmdldExpbmUoc3RhcnRQb2ludC5saW5lKTtcbiAgICAgICAgc3RhcnQgPSB0ZXh0LnNsaWNlKDAsIHN0YXJ0UG9pbnQuY2gpO1xuICAgICAgICBlbmQgPSB0ZXh0LnNsaWNlKHN0YXJ0UG9pbnQuY2gpO1xuICAgICAgICBpZiAodHlwZSA9PSAnYm9sZCcpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvKFxcKlxcKnxfXykoPyFbXFxzXFxTXSooXFwqXFwqfF9fKSkvLCAnJyk7XG4gICAgICAgICAgICBlbmQgPSBlbmQucmVwbGFjZSgvKFxcKlxcKnxfXykvLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnaXRhbGljJykge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC8oXFwqfF8pKD8hW1xcc1xcU10qKFxcKnxfKSkvLCAnJyk7XG4gICAgICAgICAgICBlbmQgPSBlbmQucmVwbGFjZSgvKFxcKnxfKS8sICcnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdzdHJpa2V0aHJvdWdoJykge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC8oXFwqXFwqfH5+KSg/IVtcXHNcXFNdKihcXCpcXCp8fn4pKS8sICcnKTtcbiAgICAgICAgICAgIGVuZCA9IGVuZC5yZXBsYWNlKC8oXFwqXFwqfH5+KS8sICcnKTtcbiAgICAgICAgfVxuICAgICAgICBjbS5yZXBsYWNlUmFuZ2Uoc3RhcnQgKyBlbmQsIHtcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0UG9pbnQubGluZSxcbiAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsaW5lOiBzdGFydFBvaW50LmxpbmUsXG4gICAgICAgICAgICBjaDogOTk5OTk5OTk5OTk5OTksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0eXBlID09ICdib2xkJyB8fCB0eXBlID09ICdzdHJpa2V0aHJvdWdoJykge1xuICAgICAgICAgICAgc3RhcnRQb2ludC5jaCAtPSAyO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UG9pbnQgIT09IGVuZFBvaW50KSB7XG4gICAgICAgICAgICAgICAgZW5kUG9pbnQuY2ggLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdpdGFsaWMnKSB7XG4gICAgICAgICAgICBzdGFydFBvaW50LmNoIC09IDE7XG4gICAgICAgICAgICBpZiAoc3RhcnRQb2ludCAhPT0gZW5kUG9pbnQpIHtcbiAgICAgICAgICAgICAgICBlbmRQb2ludC5jaCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAodHlwZSA9PSAnYm9sZCcpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNwbGl0KCcqKicpLmpvaW4oJycpO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3BsaXQoJ19fJykuam9pbignJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnaXRhbGljJykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3BsaXQoJyonKS5qb2luKCcnKTtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNwbGl0KCdfJykuam9pbignJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNwbGl0KCd+ficpLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oc3RhcnQgKyB0ZXh0ICsgZW5kKTtcblxuICAgICAgICBzdGFydFBvaW50LmNoICs9IHN0YXJ0X2NoYXJzLmxlbmd0aDtcbiAgICAgICAgZW5kUG9pbnQuY2ggPSBzdGFydFBvaW50LmNoICsgdGV4dC5sZW5ndGg7XG4gICAgfVxuXG4gICAgY20uc2V0U2VsZWN0aW9uKHN0YXJ0UG9pbnQsIGVuZFBvaW50KTtcbiAgICBjbS5mb2N1cygpO1xufVxuXG5mdW5jdGlvbiBfY2xlYW5CbG9jayhjbSkge1xuICAgIGlmIChjbS5nZXRXcmFwcGVyRWxlbWVudCgpLmxhc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgc3RhcnRQb2ludCA9IGNtLmdldEN1cnNvcignc3RhcnQnKTtcbiAgICB2YXIgZW5kUG9pbnQgPSBjbS5nZXRDdXJzb3IoJ2VuZCcpO1xuICAgIHZhciB0ZXh0O1xuXG4gICAgZm9yICh2YXIgbGluZSA9IHN0YXJ0UG9pbnQubGluZTsgbGluZSA8PSBlbmRQb2ludC5saW5lOyBsaW5lKyspIHtcbiAgICAgICAgdGV4dCA9IGNtLmdldExpbmUobGluZSk7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL15bIF0qKFsjIF0rfFxcKnwtfFs+IF0rfFswLTldKygufFxcKSkpWyBdKi8sICcnKTtcblxuICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dCwge1xuICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgY2g6IDk5OTk5OTk5OTk5OTk5LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIG51bWJlciBvZiBieXRlcyB0byBhIGh1bWFuLXJlYWRhYmxlIGZpbGUgc2l6ZS4gSWYgeW91IGRlc2lyZVxuICogdG8gYWRkIGEgc3BhY2UgYmV0d2VlbiB0aGUgdmFsdWUgYW5kIHRoZSB1bml0LCB5b3UgbmVlZCB0byBhZGQgdGhpcyBzcGFjZVxuICogdG8gdGhlIGdpdmVuIHVuaXRzLlxuICogQHBhcmFtIGJ5dGVzIHtudW1iZXJ9IEEgbnVtYmVyIG9mIGJ5dGVzLCBhcyBpbnRlZ2VyLiBFeDogNDIxMTM3XG4gKiBAcGFyYW0gdW5pdHMge251bWJlcltdfSBBbiBhcnJheSBvZiBodW1hbi1yZWFkYWJsZSB1bml0cywgaWUuIFsnIEInLCAnIEsnLCAnIE1CJ11cbiAqIEByZXR1cm5zIHN0cmluZyBBIGh1bWFuLXJlYWRhYmxlIGZpbGUgc2l6ZS4gRXg6ICc0MTIgS0InXG4gKi9cbmZ1bmN0aW9uIGh1bWFuRmlsZVNpemUoYnl0ZXMsIHVuaXRzKSB7XG4gICAgaWYgKE1hdGguYWJzKGJ5dGVzKSA8IDEwMjQpIHtcbiAgICAgICAgcmV0dXJuICcnICsgYnl0ZXMgKyB1bml0c1swXTtcbiAgICB9XG4gICAgdmFyIHUgPSAwO1xuICAgIGRvIHtcbiAgICAgICAgYnl0ZXMgLz0gMTAyNDtcbiAgICAgICAgKyt1O1xuICAgIH0gd2hpbGUgKE1hdGguYWJzKGJ5dGVzKSA+PSAxMDI0ICYmIHUgPCB1bml0cy5sZW5ndGgpO1xuICAgIHJldHVybiAnJyArIGJ5dGVzLnRvRml4ZWQoMSkgKyB1bml0c1t1XTtcbn1cblxuLy8gTWVyZ2UgdGhlIHByb3BlcnRpZXMgb2Ygb25lIG9iamVjdCBpbnRvIGFub3RoZXIuXG5mdW5jdGlvbiBfbWVyZ2VQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VbcHJvcGVydHldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XS5jb25jYXQodGFyZ2V0W3Byb3BlcnR5XSBpbnN0YW5jZW9mIEFycmF5ID8gdGFyZ2V0W3Byb3BlcnR5XSA6IFtdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBzb3VyY2VbcHJvcGVydHldID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0uY29uc3RydWN0b3IgPT09IE9iamVjdFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IF9tZXJnZVByb3BlcnRpZXModGFyZ2V0W3Byb3BlcnR5XSB8fCB7fSwgc291cmNlW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gTWVyZ2UgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBvYmplY3RzIGludG8gb25lLlxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldCA9IF9tZXJnZVByb3BlcnRpZXModGFyZ2V0LCBhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIFRoZSByaWdodCB3b3JkIGNvdW50IGluIHJlc3BlY3QgZm9yIENKSy4gKi9cbmZ1bmN0aW9uIHdvcmRDb3VudChkYXRhKSB7XG4gICAgdmFyIHBhdHRlcm4gPSAvW2EtekEtWjAtOV9cXHUwMEEwLVxcdTAyQUZcXHUwMzkyLVxcdTAzYzlcXHUwNDEwLVxcdTA0RjldK3xbXFx1NEUwMC1cXHU5RkZGXFx1MzQwMC1cXHU0ZGJmXFx1ZjkwMC1cXHVmYWZmXFx1MzA0MC1cXHUzMDlmXFx1YWMwMC1cXHVkN2FmXSsvZztcbiAgICB2YXIgbSA9IGRhdGEubWF0Y2gocGF0dGVybik7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBpZiAobSA9PT0gbnVsbCkgcmV0dXJuIGNvdW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobVtpXS5jaGFyQ29kZUF0KDApID49IDB4NEUwMCkge1xuICAgICAgICAgICAgY291bnQgKz0gbVtpXS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cblxudmFyIGljb25DbGFzc01hcCA9IHtcbiAgICAnYm9sZCc6ICdmYSBmYS1ib2xkJyxcbiAgICAnaXRhbGljJzogJ2ZhIGZhLWl0YWxpYycsXG4gICAgJ3N0cmlrZXRocm91Z2gnOiAnZmEgZmEtc3RyaWtldGhyb3VnaCcsXG4gICAgJ2hlYWRpbmcnOiAnZmEgZmEtaGVhZGVyIGZhLWhlYWRpbmcnLFxuICAgICdoZWFkaW5nLXNtYWxsZXInOiAnZmEgZmEtaGVhZGVyIGZhLWhlYWRpbmcgaGVhZGVyLXNtYWxsZXInLFxuICAgICdoZWFkaW5nLWJpZ2dlcic6ICdmYSBmYS1oZWFkZXIgZmEtaGVhZGluZyBoZWFkZXItYmlnZ2VyJyxcbiAgICAnaGVhZGluZy0xJzogJ2ZhIGZhLWhlYWRlciBmYS1oZWFkaW5nIGhlYWRlci0xJyxcbiAgICAnaGVhZGluZy0yJzogJ2ZhIGZhLWhlYWRlciBmYS1oZWFkaW5nIGhlYWRlci0yJyxcbiAgICAnaGVhZGluZy0zJzogJ2ZhIGZhLWhlYWRlciBmYS1oZWFkaW5nIGhlYWRlci0zJyxcbiAgICAnY29kZSc6ICdmYSBmYS1jb2RlJyxcbiAgICAncXVvdGUnOiAnZmEgZmEtcXVvdGUtbGVmdCcsXG4gICAgJ29yZGVyZWQtbGlzdCc6ICdmYSBmYS1saXN0LW9sJyxcbiAgICAndW5vcmRlcmVkLWxpc3QnOiAnZmEgZmEtbGlzdC11bCcsXG4gICAgJ2NsZWFuLWJsb2NrJzogJ2ZhIGZhLWVyYXNlcicsXG4gICAgJ2xpbmsnOiAnZmEgZmEtbGluaycsXG4gICAgJ2ltYWdlJzogJ2ZhIGZhLWltYWdlJyxcbiAgICAndXBsb2FkLWltYWdlJzogJ2ZhIGZhLWltYWdlJyxcbiAgICAndGFibGUnOiAnZmEgZmEtdGFibGUnLFxuICAgICdob3Jpem9udGFsLXJ1bGUnOiAnZmEgZmEtbWludXMnLFxuICAgICdwcmV2aWV3JzogJ2ZhIGZhLWV5ZScsXG4gICAgJ3NpZGUtYnktc2lkZSc6ICdmYSBmYS1jb2x1bW5zJyxcbiAgICAnZnVsbHNjcmVlbic6ICdmYSBmYS1hcnJvd3MtYWx0JyxcbiAgICAnZ3VpZGUnOiAnZmEgZmEtcXVlc3Rpb24tY2lyY2xlJyxcbiAgICAndW5kbyc6ICdmYSBmYS11bmRvJyxcbiAgICAncmVkbyc6ICdmYSBmYS1yZXBlYXQgZmEtcmVkbycsXG59O1xuXG52YXIgdG9vbGJhckJ1aWx0SW5CdXR0b25zID0ge1xuICAgICdib2xkJzoge1xuICAgICAgICBuYW1lOiAnYm9sZCcsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlQm9sZCxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2JvbGQnXSxcbiAgICAgICAgdGl0bGU6ICdCb2xkJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdpdGFsaWMnOiB7XG4gICAgICAgIG5hbWU6ICdpdGFsaWMnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUl0YWxpYyxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2l0YWxpYyddLFxuICAgICAgICB0aXRsZTogJ0l0YWxpYycsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnc3RyaWtldGhyb3VnaCc6IHtcbiAgICAgICAgbmFtZTogJ3N0cmlrZXRocm91Z2gnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZVN0cmlrZXRocm91Z2gsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydzdHJpa2V0aHJvdWdoJ10sXG4gICAgICAgIHRpdGxlOiAnU3RyaWtldGhyb3VnaCcsXG4gICAgfSxcbiAgICAnaGVhZGluZyc6IHtcbiAgICAgICAgbmFtZTogJ2hlYWRpbmcnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUhlYWRpbmdTbWFsbGVyLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaGVhZGluZyddLFxuICAgICAgICB0aXRsZTogJ0hlYWRpbmcnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ2hlYWRpbmctc21hbGxlcic6IHtcbiAgICAgICAgbmFtZTogJ2hlYWRpbmctc21hbGxlcicsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlSGVhZGluZ1NtYWxsZXIsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydoZWFkaW5nLXNtYWxsZXInXSxcbiAgICAgICAgdGl0bGU6ICdTbWFsbGVyIEhlYWRpbmcnLFxuICAgIH0sXG4gICAgJ2hlYWRpbmctYmlnZ2VyJzoge1xuICAgICAgICBuYW1lOiAnaGVhZGluZy1iaWdnZXInLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUhlYWRpbmdCaWdnZXIsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydoZWFkaW5nLWJpZ2dlciddLFxuICAgICAgICB0aXRsZTogJ0JpZ2dlciBIZWFkaW5nJyxcbiAgICB9LFxuICAgICdoZWFkaW5nLTEnOiB7XG4gICAgICAgIG5hbWU6ICdoZWFkaW5nLTEnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUhlYWRpbmcxLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaGVhZGluZy0xJ10sXG4gICAgICAgIHRpdGxlOiAnQmlnIEhlYWRpbmcnLFxuICAgIH0sXG4gICAgJ2hlYWRpbmctMic6IHtcbiAgICAgICAgbmFtZTogJ2hlYWRpbmctMicsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlSGVhZGluZzIsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydoZWFkaW5nLTInXSxcbiAgICAgICAgdGl0bGU6ICdNZWRpdW0gSGVhZGluZycsXG4gICAgfSxcbiAgICAnaGVhZGluZy0zJzoge1xuICAgICAgICBuYW1lOiAnaGVhZGluZy0zJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVIZWFkaW5nMyxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2hlYWRpbmctMyddLFxuICAgICAgICB0aXRsZTogJ1NtYWxsIEhlYWRpbmcnLFxuICAgIH0sXG4gICAgJ3NlcGFyYXRvci0xJzoge1xuICAgICAgICBuYW1lOiAnc2VwYXJhdG9yLTEnLFxuICAgIH0sXG4gICAgJ2NvZGUnOiB7XG4gICAgICAgIG5hbWU6ICdjb2RlJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVDb2RlQmxvY2ssXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydjb2RlJ10sXG4gICAgICAgIHRpdGxlOiAnQ29kZScsXG4gICAgfSxcbiAgICAncXVvdGUnOiB7XG4gICAgICAgIG5hbWU6ICdxdW90ZScsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlQmxvY2txdW90ZSxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3F1b3RlJ10sXG4gICAgICAgIHRpdGxlOiAnUXVvdGUnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ3Vub3JkZXJlZC1saXN0Jzoge1xuICAgICAgICBuYW1lOiAndW5vcmRlcmVkLWxpc3QnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZVVub3JkZXJlZExpc3QsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWyd1bm9yZGVyZWQtbGlzdCddLFxuICAgICAgICB0aXRsZTogJ0dlbmVyaWMgTGlzdCcsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnb3JkZXJlZC1saXN0Jzoge1xuICAgICAgICBuYW1lOiAnb3JkZXJlZC1saXN0JyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVPcmRlcmVkTGlzdCxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ29yZGVyZWQtbGlzdCddLFxuICAgICAgICB0aXRsZTogJ051bWJlcmVkIExpc3QnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ2NsZWFuLWJsb2NrJzoge1xuICAgICAgICBuYW1lOiAnY2xlYW4tYmxvY2snLFxuICAgICAgICBhY3Rpb246IGNsZWFuQmxvY2ssXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydjbGVhbi1ibG9jayddLFxuICAgICAgICB0aXRsZTogJ0NsZWFuIGJsb2NrJyxcbiAgICB9LFxuICAgICdzZXBhcmF0b3ItMic6IHtcbiAgICAgICAgbmFtZTogJ3NlcGFyYXRvci0yJyxcbiAgICB9LFxuICAgICdsaW5rJzoge1xuICAgICAgICBuYW1lOiAnbGluaycsXG4gICAgICAgIGFjdGlvbjogZHJhd0xpbmssXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydsaW5rJ10sXG4gICAgICAgIHRpdGxlOiAnQ3JlYXRlIExpbmsnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ2ltYWdlJzoge1xuICAgICAgICBuYW1lOiAnaW1hZ2UnLFxuICAgICAgICBhY3Rpb246IGRyYXdJbWFnZSxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2ltYWdlJ10sXG4gICAgICAgIHRpdGxlOiAnSW5zZXJ0IEltYWdlJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICd1cGxvYWQtaW1hZ2UnOiB7XG4gICAgICAgIG5hbWU6ICd1cGxvYWQtaW1hZ2UnLFxuICAgICAgICBhY3Rpb246IGRyYXdVcGxvYWRlZEltYWdlLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsndXBsb2FkLWltYWdlJ10sXG4gICAgICAgIHRpdGxlOiAnSW1wb3J0IGFuIGltYWdlJyxcbiAgICB9LFxuICAgICd0YWJsZSc6IHtcbiAgICAgICAgbmFtZTogJ3RhYmxlJyxcbiAgICAgICAgYWN0aW9uOiBkcmF3VGFibGUsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWyd0YWJsZSddLFxuICAgICAgICB0aXRsZTogJ0luc2VydCBUYWJsZScsXG4gICAgfSxcbiAgICAnaG9yaXpvbnRhbC1ydWxlJzoge1xuICAgICAgICBuYW1lOiAnaG9yaXpvbnRhbC1ydWxlJyxcbiAgICAgICAgYWN0aW9uOiBkcmF3SG9yaXpvbnRhbFJ1bGUsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydob3Jpem9udGFsLXJ1bGUnXSxcbiAgICAgICAgdGl0bGU6ICdJbnNlcnQgSG9yaXpvbnRhbCBMaW5lJyxcbiAgICB9LFxuICAgICdzZXBhcmF0b3ItMyc6IHtcbiAgICAgICAgbmFtZTogJ3NlcGFyYXRvci0zJyxcbiAgICB9LFxuICAgICdwcmV2aWV3Jzoge1xuICAgICAgICBuYW1lOiAncHJldmlldycsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlUHJldmlldyxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3ByZXZpZXcnXSxcbiAgICAgICAgbm9EaXNhYmxlOiB0cnVlLFxuICAgICAgICB0aXRsZTogJ1RvZ2dsZSBQcmV2aWV3JyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdzaWRlLWJ5LXNpZGUnOiB7XG4gICAgICAgIG5hbWU6ICdzaWRlLWJ5LXNpZGUnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZVNpZGVCeVNpZGUsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydzaWRlLWJ5LXNpZGUnXSxcbiAgICAgICAgbm9EaXNhYmxlOiB0cnVlLFxuICAgICAgICBub01vYmlsZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICdUb2dnbGUgU2lkZSBieSBTaWRlJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdmdWxsc2NyZWVuJzoge1xuICAgICAgICBuYW1lOiAnZnVsbHNjcmVlbicsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlRnVsbFNjcmVlbixcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2Z1bGxzY3JlZW4nXSxcbiAgICAgICAgbm9EaXNhYmxlOiB0cnVlLFxuICAgICAgICBub01vYmlsZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICdUb2dnbGUgRnVsbHNjcmVlbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnc2VwYXJhdG9yLTQnOiB7XG4gICAgICAgIG5hbWU6ICdzZXBhcmF0b3ItNCcsXG4gICAgfSxcbiAgICAnZ3VpZGUnOiB7XG4gICAgICAgIG5hbWU6ICdndWlkZScsXG4gICAgICAgIGFjdGlvbjogJ2h0dHBzOi8vd3d3Lm1hcmtkb3duZ3VpZGUub3JnL2Jhc2ljLXN5bnRheC8nLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnZ3VpZGUnXSxcbiAgICAgICAgbm9EaXNhYmxlOiB0cnVlLFxuICAgICAgICB0aXRsZTogJ01hcmtkb3duIEd1aWRlJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdzZXBhcmF0b3ItNSc6IHtcbiAgICAgICAgbmFtZTogJ3NlcGFyYXRvci01JyxcbiAgICB9LFxuICAgICd1bmRvJzoge1xuICAgICAgICBuYW1lOiAndW5kbycsXG4gICAgICAgIGFjdGlvbjogdW5kbyxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3VuZG8nXSxcbiAgICAgICAgbm9EaXNhYmxlOiB0cnVlLFxuICAgICAgICB0aXRsZTogJ1VuZG8nLFxuICAgIH0sXG4gICAgJ3JlZG8nOiB7XG4gICAgICAgIG5hbWU6ICdyZWRvJyxcbiAgICAgICAgYWN0aW9uOiByZWRvLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsncmVkbyddLFxuICAgICAgICBub0Rpc2FibGU6IHRydWUsXG4gICAgICAgIHRpdGxlOiAnUmVkbycsXG4gICAgfSxcbn07XG5cbnZhciBpbnNlcnRUZXh0cyA9IHtcbiAgICBsaW5rOiBbJ1snLCAnXSgjdXJsIyknXSxcbiAgICBpbWFnZTogWychWycsICddKCN1cmwjKSddLFxuICAgIHVwbG9hZGVkSW1hZ2U6IFsnIVtdKCN1cmwjKScsICcnXSxcbiAgICAvLyB1cGxvYWRlZEltYWdlOiBbJyFbXSgjdXJsIylcXG4nLCAnJ10sIC8vIFRPRE86IE5ldyBsaW5lIGluc2VydGlvbiBkb2Vzbid0IHdvcmsgaGVyZS5cbiAgICB0YWJsZTogWycnLCAnXFxuXFxufCBDb2x1bW4gMSB8IENvbHVtbiAyIHwgQ29sdW1uIDMgfFxcbnwgLS0tLS0tLS0gfCAtLS0tLS0tLSB8IC0tLS0tLS0tIHxcXG58IFRleHQgICAgIHwgVGV4dCAgICAgfCBUZXh0ICAgICB8XFxuXFxuJ10sXG4gICAgaG9yaXpvbnRhbFJ1bGU6IFsnJywgJ1xcblxcbi0tLS0tXFxuXFxuJ10sXG59O1xuXG52YXIgcHJvbXB0VGV4dHMgPSB7XG4gICAgbGluazogJ1VSTCBmb3IgdGhlIGxpbms6JyxcbiAgICBpbWFnZTogJ1VSTCBvZiB0aGUgaW1hZ2U6Jyxcbn07XG5cbnZhciB0aW1lRm9ybWF0ID0ge1xuICAgIGxvY2FsZTogJ2VuLVVTJyxcbiAgICBmb3JtYXQ6IHtcbiAgICAgICAgaG91cjogJzItZGlnaXQnLFxuICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICB9LFxufTtcblxudmFyIGJsb2NrU3R5bGVzID0ge1xuICAgICdib2xkJzogJyoqJyxcbiAgICAnY29kZSc6ICdgYGAnLFxuICAgICdpdGFsaWMnOiAnKicsXG59O1xuXG4vKipcbiAqIFRleHRzIGRpc3BsYXllZCB0byB0aGUgdXNlciAobWFpbmx5IG9uIHRoZSBzdGF0dXMgYmFyKSBmb3IgdGhlIGltcG9ydCBpbWFnZVxuICogZmVhdHVyZS4gQ2FuIGJlIHVzZWQgZm9yIGN1c3RvbWl6YXRpb24gb3IgaW50ZXJuYXRpb25hbGl6YXRpb24uXG4gKi9cbnZhciBpbWFnZVRleHRzID0ge1xuICAgIHNiSW5pdDogJ0F0dGFjaCBmaWxlcyBieSBkcmFnIGFuZCBkcm9wcGluZyBvciBwYXN0aW5nIGZyb20gY2xpcGJvYXJkLicsXG4gICAgc2JPbkRyYWdFbnRlcjogJ0Ryb3AgaW1hZ2UgdG8gdXBsb2FkIGl0LicsXG4gICAgc2JPbkRyb3A6ICdVcGxvYWRpbmcgaW1hZ2UgI2ltYWdlc19uYW1lcyMuLi4nLFxuICAgIHNiUHJvZ3Jlc3M6ICdVcGxvYWRpbmcgI2ZpbGVfbmFtZSM6ICNwcm9ncmVzcyMlJyxcbiAgICBzYk9uVXBsb2FkZWQ6ICdVcGxvYWRlZCAjaW1hZ2VfbmFtZSMnLFxuICAgIHNpemVVbml0czogJyBCLCBLQiwgTUInLFxufTtcblxuLyoqXG4gKiBFcnJvcnMgZGlzcGxheWVkIHRvIHRoZSB1c2VyLCB1c2luZyB0aGUgYGVycm9yQ2FsbGJhY2tgIG9wdGlvbi4gQ2FuIGJlIHVzZWQgZm9yXG4gKiBjdXN0b21pemF0aW9uIG9yIGludGVybmF0aW9uYWxpemF0aW9uLlxuICovXG52YXIgZXJyb3JNZXNzYWdlcyA9IHtcbiAgICBub0ZpbGVHaXZlbjogJ1lvdSBtdXN0IHNlbGVjdCBhIGZpbGUuJyxcbiAgICB0eXBlTm90QWxsb3dlZDogJ1RoaXMgaW1hZ2UgdHlwZSBpcyBub3QgYWxsb3dlZC4nLFxuICAgIGZpbGVUb29MYXJnZTogJ0ltYWdlICNpbWFnZV9uYW1lIyBpcyB0b28gYmlnICgjaW1hZ2Vfc2l6ZSMpLlxcbicgK1xuICAgICAgICAnTWF4aW11bSBmaWxlIHNpemUgaXMgI2ltYWdlX21heF9zaXplIy4nLFxuICAgIGltcG9ydEVycm9yOiAnU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hlbiB1cGxvYWRpbmcgdGhlIGltYWdlICNpbWFnZV9uYW1lIy4nLFxufTtcblxuLyoqXG4gKiBJbnRlcmZhY2Ugb2YgRWFzeU1ERS5cbiAqL1xuZnVuY3Rpb24gRWFzeU1ERShvcHRpb25zKSB7XG4gICAgLy8gSGFuZGxlIG9wdGlvbnMgcGFyYW1ldGVyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBVc2VkIGxhdGVyIHRvIHJlZmVyIHRvIGl0XCJzIHBhcmVudFxuICAgIG9wdGlvbnMucGFyZW50ID0gdGhpcztcblxuICAgIC8vIENoZWNrIGlmIEZvbnQgQXdlc29tZSBuZWVkcyB0byBiZSBhdXRvIGRvd25sb2FkZWRcbiAgICB2YXIgYXV0b0Rvd25sb2FkRkEgPSB0cnVlO1xuXG4gICAgaWYgKG9wdGlvbnMuYXV0b0Rvd25sb2FkRm9udEF3ZXNvbWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGF1dG9Eb3dubG9hZEZBID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXV0b0Rvd25sb2FkRm9udEF3ZXNvbWUgIT09IHRydWUpIHtcbiAgICAgICAgdmFyIHN0eWxlU2hlZXRzID0gZG9jdW1lbnQuc3R5bGVTaGVldHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVTaGVldHNbaV0uaHJlZilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlU2hlZXRzW2ldLmhyZWYuaW5kZXhPZignLy9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9mb250LWF3ZXNvbWUvJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGF1dG9Eb3dubG9hZEZBID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXV0b0Rvd25sb2FkRkEpIHtcbiAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgICAgICBsaW5rLmhyZWYgPSAnaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9mb250LWF3ZXNvbWUvbGF0ZXN0L2Nzcy9mb250LWF3ZXNvbWUubWluLmNzcyc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XG4gICAgfVxuXG5cbiAgICAvLyBGaW5kIHRoZSB0ZXh0YXJlYSB0byB1c2VcbiAgICBpZiAob3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIGVsZW1lbnQgb3B0aW9uIHdhcyBzcGVjaWZpZWQsIGJ1dCBubyBlbGVtZW50IHdhcyBmb3VuZFxuICAgICAgICBjb25zb2xlLmxvZygnRWFzeU1ERTogRXJyb3IuIE5vIGVsZW1lbnQgd2FzIGZvdW5kLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBIYW5kbGUgdG9vbGJhclxuICAgIGlmIChvcHRpb25zLnRvb2xiYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBJbml0aWFsaXplXG4gICAgICAgIG9wdGlvbnMudG9vbGJhciA9IFtdO1xuXG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIHRoZSBidWlsdCBpbiBidXR0b25zLCB0byBnZXQgdGhlIHByZWZlcnJlZCBvcmRlclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdG9vbGJhckJ1aWx0SW5CdXR0b25zKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvb2xiYXJCdWlsdEluQnV0dG9ucywga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignc2VwYXJhdG9yLScpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG9vbGJhci5wdXNoKCd8Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRvb2xiYXJCdWlsdEluQnV0dG9uc1trZXldLmRlZmF1bHQgPT09IHRydWUgfHwgKG9wdGlvbnMuc2hvd0ljb25zICYmIG9wdGlvbnMuc2hvd0ljb25zLmNvbnN0cnVjdG9yID09PSBBcnJheSAmJiBvcHRpb25zLnNob3dJY29ucy5pbmRleE9mKGtleSkgIT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG9vbGJhci5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRWRpdG9yIHByZXZpZXcgc3R5bGluZyBjbGFzcy5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAncHJldmlld0NsYXNzJykpIHtcbiAgICAgICAgb3B0aW9ucy5wcmV2aWV3Q2xhc3MgPSAnZWRpdG9yLXByZXZpZXcnO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzdGF0dXMgYmFyXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3N0YXR1cycpKSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0gWydhdXRvc2F2ZScsICdsaW5lcycsICd3b3JkcycsICdjdXJzb3InXTtcblxuICAgICAgICBpZiAob3B0aW9ucy51cGxvYWRJbWFnZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMudW5zaGlmdCgndXBsb2FkLWltYWdlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIEFkZCBkZWZhdWx0IHByZXZpZXcgcmVuZGVyaW5nIGZ1bmN0aW9uXG4gICAgaWYgKCFvcHRpb25zLnByZXZpZXdSZW5kZXIpIHtcbiAgICAgICAgb3B0aW9ucy5wcmV2aWV3UmVuZGVyID0gZnVuY3Rpb24gKHBsYWluVGV4dCkge1xuICAgICAgICAgICAgLy8gTm90ZTogXCJ0aGlzXCIgcmVmZXJzIHRvIHRoZSBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm1hcmtkb3duKHBsYWluVGV4dCk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvLyBTZXQgZGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIGNvbmZpZ1xuICAgIG9wdGlvbnMucGFyc2luZ0NvbmZpZyA9IGV4dGVuZCh7XG4gICAgICAgIGhpZ2hsaWdodEZvcm1hdHRpbmc6IHRydWUsIC8vIG5lZWRlZCBmb3IgdG9nZ2xlQ29kZUJsb2NrIHRvIGRldGVjdCB0eXBlcyBvZiBjb2RlXG4gICAgfSwgb3B0aW9ucy5wYXJzaW5nQ29uZmlnIHx8IHt9KTtcblxuXG4gICAgLy8gTWVyZ2luZyB0aGUgaW5zZXJ0VGV4dHMsIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICBvcHRpb25zLmluc2VydFRleHRzID0gZXh0ZW5kKHt9LCBpbnNlcnRUZXh0cywgb3B0aW9ucy5pbnNlcnRUZXh0cyB8fCB7fSk7XG5cblxuICAgIC8vIE1lcmdpbmcgdGhlIHByb21wdFRleHRzLCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG4gICAgb3B0aW9ucy5wcm9tcHRUZXh0cyA9IGV4dGVuZCh7fSwgcHJvbXB0VGV4dHMsIG9wdGlvbnMucHJvbXB0VGV4dHMgfHwge30pO1xuXG5cbiAgICAvLyBNZXJnaW5nIHRoZSBibG9ja1N0eWxlcywgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgIG9wdGlvbnMuYmxvY2tTdHlsZXMgPSBleHRlbmQoe30sIGJsb2NrU3R5bGVzLCBvcHRpb25zLmJsb2NrU3R5bGVzIHx8IHt9KTtcblxuXG4gICAgaWYgKG9wdGlvbnMuYXV0b3NhdmUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE1lcmdpbmcgdGhlIEF1dG9zYXZlIHRpbWVGb3JtYXQsIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucy5hdXRvc2F2ZS50aW1lRm9ybWF0ID0gZXh0ZW5kKHt9LCB0aW1lRm9ybWF0LCBvcHRpb25zLmF1dG9zYXZlLnRpbWVGb3JtYXQgfHwge30pO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaWNvbkNsYXNzTWFwID0gZXh0ZW5kKHt9LCBpY29uQ2xhc3NNYXAsIG9wdGlvbnMuaWNvbkNsYXNzTWFwIHx8IHt9KTtcblxuICAgIC8vIE1lcmdpbmcgdGhlIHNob3J0Y3V0cywgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgIG9wdGlvbnMuc2hvcnRjdXRzID0gZXh0ZW5kKHt9LCBzaG9ydGN1dHMsIG9wdGlvbnMuc2hvcnRjdXRzIHx8IHt9KTtcblxuICAgIG9wdGlvbnMubWF4SGVpZ2h0ID0gb3B0aW9ucy5tYXhIZWlnaHQgfHwgdW5kZWZpbmVkO1xuXG4gICAgb3B0aW9ucy5kaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCAnbHRyJztcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXhIZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE1pbiBhbmQgbWF4IGhlaWdodCBhcmUgZXF1YWwgaWYgbWF4SGVpZ2h0IGlzIHNldFxuICAgICAgICBvcHRpb25zLm1pbkhlaWdodCA9IG9wdGlvbnMubWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMubWluSGVpZ2h0ID0gb3B0aW9ucy5taW5IZWlnaHQgfHwgJzMwMHB4JztcbiAgICB9XG5cbiAgICBvcHRpb25zLmVycm9yQ2FsbGJhY2sgPSBvcHRpb25zLmVycm9yQ2FsbGJhY2sgfHwgZnVuY3Rpb24gKGVycm9yTWVzc2FnZSkge1xuICAgICAgICBhbGVydChlcnJvck1lc3NhZ2UpO1xuICAgIH07XG5cbiAgICAvLyBJbXBvcnQtaW1hZ2UgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgb3B0aW9ucy51cGxvYWRJbWFnZSA9IG9wdGlvbnMudXBsb2FkSW1hZ2UgfHwgZmFsc2U7XG4gICAgb3B0aW9ucy5pbWFnZU1heFNpemUgPSBvcHRpb25zLmltYWdlTWF4U2l6ZSB8fCAyMDk3MTUyOyAvLyAxMDI0ICogMTAyNCAqIDJcbiAgICBvcHRpb25zLmltYWdlQWNjZXB0ID0gb3B0aW9ucy5pbWFnZUFjY2VwdCB8fCAnaW1hZ2UvcG5nLCBpbWFnZS9qcGVnLCBpbWFnZS9naWYsIGltYWdlL2F2aWYnO1xuICAgIG9wdGlvbnMuaW1hZ2VUZXh0cyA9IGV4dGVuZCh7fSwgaW1hZ2VUZXh0cywgb3B0aW9ucy5pbWFnZVRleHRzIHx8IHt9KTtcbiAgICBvcHRpb25zLmVycm9yTWVzc2FnZXMgPSBleHRlbmQoe30sIGVycm9yTWVzc2FnZXMsIG9wdGlvbnMuZXJyb3JNZXNzYWdlcyB8fCB7fSk7XG4gICAgb3B0aW9ucy5pbWFnZVBhdGhBYnNvbHV0ZSA9IG9wdGlvbnMuaW1hZ2VQYXRoQWJzb2x1dGUgfHwgZmFsc2U7XG4gICAgb3B0aW9ucy5pbWFnZUNTUkZOYW1lID0gb3B0aW9ucy5pbWFnZUNTUkZOYW1lIHx8ICdjc3JmbWlkZGxld2FyZXRva2VuJztcbiAgICBvcHRpb25zLmltYWdlQ1NSRkhlYWRlciA9IG9wdGlvbnMuaW1hZ2VDU1JGSGVhZGVyIHx8IGZhbHNlO1xuXG5cbiAgICAvLyBDaGFuZ2UgdW5pcXVlX2lkIHRvIHVuaXF1ZUlkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChvcHRpb25zLmF1dG9zYXZlICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zLmF1dG9zYXZlLnVuaXF1ZV9pZCAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVfaWQgIT0gJycpXG4gICAgICAgIG9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQgPSBvcHRpb25zLmF1dG9zYXZlLnVuaXF1ZV9pZDtcblxuICAgIC8vIElmIG92ZXJsYXkgbW9kZSBpcyBzcGVjaWZpZWQgYW5kIGNvbWJpbmUgaXMgbm90IHByb3ZpZGVkLCBkZWZhdWx0IGl0IHRvIHRydWVcbiAgICBpZiAob3B0aW9ucy5vdmVybGF5TW9kZSAmJiBvcHRpb25zLm92ZXJsYXlNb2RlLmNvbWJpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLm92ZXJsYXlNb2RlLmNvbWJpbmUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGlzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cbiAgICAvLyBBdXRvIHJlbmRlclxuICAgIHRoaXMucmVuZGVyKCk7XG5cblxuICAgIC8vIFRoZSBjb2RlbWlycm9yIGNvbXBvbmVudCBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciByZW5kZXJpbmdcbiAgICAvLyBzbywgdGhlIHNldHRlciBmb3IgdGhlIGluaXRpYWxWYWx1ZSBjYW4gb25seSBydW4gYWZ0ZXJcbiAgICAvLyB0aGUgZWxlbWVudCBoYXMgYmVlbiByZW5kZXJlZFxuICAgIGlmIChvcHRpb25zLmluaXRpYWxWYWx1ZSAmJiAoIXRoaXMub3B0aW9ucy5hdXRvc2F2ZSB8fCB0aGlzLm9wdGlvbnMuYXV0b3NhdmUuZm91bmRTYXZlZFZhbHVlICE9PSB0cnVlKSkge1xuICAgICAgICB0aGlzLnZhbHVlKG9wdGlvbnMuaW5pdGlhbFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51cGxvYWRJbWFnZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLm9uKCdkcmFnZW50ZXInLCBmdW5jdGlvbiAoY20sIGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2JPbkRyYWdFbnRlcik7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ2RyYWdlbmQnLCBmdW5jdGlvbiAoY20sIGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2JJbml0KTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5vbignZHJhZ2xlYXZlJywgZnVuY3Rpb24gKGNtLCBldmVudCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNiSW5pdCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5vbignZHJhZ292ZXInLCBmdW5jdGlvbiAoY20sIGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2JPbkRyYWdFbnRlcik7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5vbignZHJvcCcsIGZ1bmN0aW9uIChjbSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmltYWdlVXBsb2FkRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlc1VzaW5nQ3VzdG9tRnVuY3Rpb24ob3B0aW9ucy5pbWFnZVVwbG9hZEZ1bmN0aW9uLCBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlcyhldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ3Bhc3RlJywgZnVuY3Rpb24gKGNtLCBldmVudCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW1hZ2VVcGxvYWRGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGYudXBsb2FkSW1hZ2VzVXNpbmdDdXN0b21GdW5jdGlvbihvcHRpb25zLmltYWdlVXBsb2FkRnVuY3Rpb24sIGV2ZW50LmNsaXBib2FyZERhdGEuZmlsZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlcyhldmVudC5jbGlwYm9hcmREYXRhLmZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFVwbG9hZCBhc3luY2hyb25vdXNseSBhIGxpc3Qgb2YgaW1hZ2VzIHRvIGEgc2VydmVyLlxuICpcbiAqIENhbiBiZSB0cmlnZ2VyZWQgYnk6XG4gKiAtIGRyYWcmZHJvcDtcbiAqIC0gY29weS1wYXN0ZTtcbiAqIC0gdGhlIGJyb3dzZS1maWxlIHdpbmRvdyAob3BlbmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSAqdXBsb2FkLWltYWdlKiBpY29uKS5cbiAqIEBwYXJhbSB7RmlsZUxpc3R9IGZpbGVzIFRoZSBmaWxlcyB0byB1cGxvYWQgdGhlIHRoZSBzZXJ2ZXIuXG4gKiBAcGFyYW0gW29uU3VjY2Vzc10ge2Z1bmN0aW9ufSBzZWUgRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VcbiAqIEBwYXJhbSBbb25FcnJvcl0ge2Z1bmN0aW9ufSBzZWUgRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VcbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VzID0gZnVuY3Rpb24gKGZpbGVzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lcy5wdXNoKGZpbGVzW2ldLm5hbWUpO1xuICAgICAgICB0aGlzLnVwbG9hZEltYWdlKGZpbGVzW2ldLCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgdGhpcy5vcHRpb25zLmltYWdlVGV4dHMuc2JPbkRyb3AucmVwbGFjZSgnI2ltYWdlc19uYW1lcyMnLCBuYW1lcy5qb2luKCcsICcpKSk7XG59O1xuXG4vKipcbiAqIFVwbG9hZCBhc3luY2hyb25vdXNseSBhIGxpc3Qgb2YgaW1hZ2VzIHRvIGEgc2VydmVyLlxuICpcbiAqIENhbiBiZSB0cmlnZ2VyZWQgYnk6XG4gKiAtIGRyYWcmZHJvcDtcbiAqIC0gY29weS1wYXN0ZTtcbiAqIC0gdGhlIGJyb3dzZS1maWxlIHdpbmRvdyAob3BlbmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSAqdXBsb2FkLWltYWdlKiBpY29uKS5cbiAqIEBwYXJhbSBpbWFnZVVwbG9hZEZ1bmN0aW9uIHtGdW5jdGlvbn0gVGhlIGN1c3RvbSBmdW5jdGlvbiB0byB1cGxvYWQgdGhlIGltYWdlIHBhc3NlZCBpbiBvcHRpb25zLlxuICogQHBhcmFtIHtGaWxlTGlzdH0gZmlsZXMgVGhlIGZpbGVzIHRvIHVwbG9hZCB0aGUgdGhlIHNlcnZlci5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VzVXNpbmdDdXN0b21GdW5jdGlvbiA9IGZ1bmN0aW9uIChpbWFnZVVwbG9hZEZ1bmN0aW9uLCBmaWxlcykge1xuICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWVzLnB1c2goZmlsZXNbaV0ubmFtZSk7XG4gICAgICAgIHRoaXMudXBsb2FkSW1hZ2VVc2luZ0N1c3RvbUZ1bmN0aW9uKGltYWdlVXBsb2FkRnVuY3Rpb24sIGZpbGVzW2ldKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHRoaXMub3B0aW9ucy5pbWFnZVRleHRzLnNiT25Ecm9wLnJlcGxhY2UoJyNpbWFnZXNfbmFtZXMjJywgbmFtZXMuam9pbignLCAnKSkpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYW4gaXRlbSBpbiB0aGUgc3RhdHVzIGJhci5cbiAqIEBwYXJhbSBpdGVtTmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgaXRlbSB0byB1cGRhdGUgKGllLiAndXBsb2FkLWltYWdlJywgJ2F1dG9zYXZlJywgZXRjLikuXG4gKiBAcGFyYW0gY29udGVudCB7c3RyaW5nfSB0aGUgbmV3IGNvbnRlbnQgb2YgdGhlIGl0ZW0gdG8gd3JpdGUgaW4gdGhlIHN0YXR1cyBiYXIuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnVwZGF0ZVN0YXR1c0JhciA9IGZ1bmN0aW9uIChpdGVtTmFtZSwgY29udGVudCkge1xuICAgIGlmICghdGhpcy5ndWkuc3RhdHVzYmFyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hpbmdDbGFzc2VzID0gdGhpcy5ndWkuc3RhdHVzYmFyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaXRlbU5hbWUpO1xuICAgIGlmIChtYXRjaGluZ0NsYXNzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuZ3VpLnN0YXR1c2Jhci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGl0ZW1OYW1lKVswXS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmIChtYXRjaGluZ0NsYXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFYXN5TURFOiBzdGF0dXMgYmFyIGl0ZW0gJyArIGl0ZW1OYW1lICsgJyB3YXMgbm90IGZvdW5kLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFYXN5TURFOiBTZXZlcmFsIHN0YXR1cyBiYXIgaXRlbXMgbmFtZWQgJyArIGl0ZW1OYW1lICsgJyB3YXMgZm91bmQuJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IG1hcmtkb3duIHJlbmRlci5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUubWFya2Rvd24gPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIGlmIChtYXJrZWQpIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZVxuICAgICAgICB2YXIgbWFya2VkT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnICYmIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcubWFya2VkT3B0aW9ucykge1xuICAgICAgICAgICAgbWFya2VkT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcubWFya2VkT3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtlZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBvcHRpb25zXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZyAmJiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnLnNpbmdsZUxpbmVCcmVha3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtYXJrZWRPcHRpb25zLmJyZWFrcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFya2VkT3B0aW9ucy5icmVha3MgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnICYmIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcuY29kZVN5bnRheEhpZ2hsaWdodGluZyA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAvKiBHZXQgSExKUyBmcm9tIGNvbmZpZyBvciB3aW5kb3cgKi9cbiAgICAgICAgICAgIHZhciBobGpzID0gdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZy5obGpzIHx8IHdpbmRvdy5obGpzO1xuXG4gICAgICAgICAgICAvKiBDaGVjayBpZiBITEpTIGxvYWRlZCAqL1xuICAgICAgICAgICAgaWYgKGhsanMpIHtcbiAgICAgICAgICAgICAgICBtYXJrZWRPcHRpb25zLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChjb2RlLCBsYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5ndWFnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBobGpzLmhpZ2hsaWdodChsYW5ndWFnZSwgY29kZSkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGxqcy5oaWdobGlnaHRBdXRvKGNvZGUpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBvcHRpb25zXG4gICAgICAgIG1hcmtlZC5zZXRPcHRpb25zKG1hcmtlZE9wdGlvbnMpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG1hcmtkb3duIHRvIEhUTUxcbiAgICAgICAgdmFyIGh0bWxUZXh0ID0gbWFya2VkLnBhcnNlKHRleHQpO1xuXG4gICAgICAgIC8vIFNhbml0aXplIEhUTUxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcuc2FuaXRpemVyRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGh0bWxUZXh0ID0gdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZy5zYW5pdGl6ZXJGdW5jdGlvbi5jYWxsKHRoaXMsIGh0bWxUZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVkaXQgdGhlIEhUTUwgYW5jaG9ycyB0byBhZGQgJ3RhcmdldD1cIl9ibGFua1wiJyBieSBkZWZhdWx0LlxuICAgICAgICBodG1sVGV4dCA9IGFkZEFuY2hvclRhcmdldEJsYW5rKGh0bWxUZXh0KTtcblxuICAgICAgICAvLyBSZW1vdmUgbGlzdC1zdHlsZSB3aGVuIHJlbmRlcmluZyBjaGVja2JveGVzXG4gICAgICAgIGh0bWxUZXh0ID0gcmVtb3ZlTGlzdFN0eWxlV2hlbkNoZWNrYm94KGh0bWxUZXh0KTtcblxuICAgICAgICByZXR1cm4gaHRtbFRleHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW5kZXIgZWRpdG9yIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICovXG5FYXN5TURFLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIGVsID0gdGhpcy5lbGVtZW50IHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZXh0YXJlYScpWzBdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW5kZXJlZCAmJiB0aGlzLl9yZW5kZXJlZCA9PT0gZWwpIHtcbiAgICAgICAgLy8gQWxyZWFkeSByZW5kZXJlZC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudCA9IGVsO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBrZXlNYXBzID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5zaG9ydGN1dHMpIHtcbiAgICAgICAgLy8gbnVsbCBzdGFuZHMgZm9yIFwiZG8gbm90IGJpbmQgdGhpcyBjb21tYW5kXCJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvcnRjdXRzW2tleV0gIT09IG51bGwgJiYgYmluZGluZ3Nba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXlNYXBzW2ZpeFNob3J0Y3V0KG9wdGlvbnMuc2hvcnRjdXRzW2tleV0pXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGJpbmRpbmdzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24oc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGFjdGlvbiwgJ19ibGFuaycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlNYXBzWydFbnRlciddID0gJ25ld2xpbmVBbmRJbmRlbnRDb250aW51ZU1hcmtkb3duTGlzdCc7XG4gICAga2V5TWFwc1snVGFiJ10gPSAndGFiQW5kSW5kZW50TWFya2Rvd25MaXN0JztcbiAgICBrZXlNYXBzWydTaGlmdC1UYWInXSA9ICdzaGlmdFRhYkFuZFVuaW5kZW50TWFya2Rvd25MaXN0JztcbiAgICBrZXlNYXBzWydFc2MnXSA9IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKCdmdWxsU2NyZWVuJykpIHRvZ2dsZUZ1bGxTY3JlZW4oc2VsZik7XG4gICAgfTtcblxuICAgIHRoaXMuZG9jdW1lbnRPbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAyNykge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29kZW1pcnJvci5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSkgdG9nZ2xlRnVsbFNjcmVlbihzZWxmKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuZG9jdW1lbnRPbktleURvd24sIGZhbHNlKTtcblxuICAgIHZhciBtb2RlLCBiYWNrZHJvcDtcblxuICAgIC8vIENvZGVNaXJyb3Igb3ZlcmxheSBtb2RlXG4gICAgaWYgKG9wdGlvbnMub3ZlcmxheU1vZGUpIHtcbiAgICAgICAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKCdvdmVybGF5LW1vZGUnLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5vdmVybGF5TW9kZShDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCBvcHRpb25zLnNwZWxsQ2hlY2tlciAhPT0gZmFsc2UgPyAnc3BlbGwtY2hlY2tlcicgOiAnZ2ZtJyksIG9wdGlvbnMub3ZlcmxheU1vZGUubW9kZSwgb3B0aW9ucy5vdmVybGF5TW9kZS5jb21iaW5lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kZSA9ICdvdmVybGF5LW1vZGUnO1xuICAgICAgICBiYWNrZHJvcCA9IG9wdGlvbnMucGFyc2luZ0NvbmZpZztcbiAgICAgICAgYmFja2Ryb3AuZ2l0SHViU3BpY2UgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlID0gb3B0aW9ucy5wYXJzaW5nQ29uZmlnO1xuICAgICAgICBtb2RlLm5hbWUgPSAnZ2ZtJztcbiAgICAgICAgbW9kZS5naXRIdWJTcGljZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcGVsbENoZWNrZXIgIT09IGZhbHNlKSB7XG4gICAgICAgIG1vZGUgPSAnc3BlbGwtY2hlY2tlcic7XG4gICAgICAgIGJhY2tkcm9wID0gb3B0aW9ucy5wYXJzaW5nQ29uZmlnO1xuICAgICAgICBiYWNrZHJvcC5uYW1lID0gJ2dmbSc7XG4gICAgICAgIGJhY2tkcm9wLmdpdEh1YlNwaWNlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNwZWxsQ2hlY2tlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucy5zcGVsbENoZWNrZXIoe1xuICAgICAgICAgICAgICAgIGNvZGVNaXJyb3JJbnN0YW5jZTogQ29kZU1pcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQ29kZU1pcnJvclNwZWxsQ2hlY2tlcih7XG4gICAgICAgICAgICAgICAgY29kZU1pcnJvckluc3RhbmNlOiBDb2RlTWlycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBmdW5jdGlvbiBjb25maWd1cmVNb3VzZShjbSwgcmVwZWF0LCBldmVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkTmV3OiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmNvZGVtaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYShlbCwge1xuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBiYWNrZHJvcDogYmFja2Ryb3AsXG4gICAgICAgIHRoZW1lOiAob3B0aW9ucy50aGVtZSAhPSB1bmRlZmluZWQpID8gb3B0aW9ucy50aGVtZSA6ICdlYXN5bWRlJyxcbiAgICAgICAgdGFiU2l6ZTogKG9wdGlvbnMudGFiU2l6ZSAhPSB1bmRlZmluZWQpID8gb3B0aW9ucy50YWJTaXplIDogMixcbiAgICAgICAgaW5kZW50VW5pdDogKG9wdGlvbnMudGFiU2l6ZSAhPSB1bmRlZmluZWQpID8gb3B0aW9ucy50YWJTaXplIDogMixcbiAgICAgICAgaW5kZW50V2l0aFRhYnM6IChvcHRpb25zLmluZGVudFdpdGhUYWJzID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgIGxpbmVOdW1iZXJzOiAob3B0aW9ucy5saW5lTnVtYmVycyA9PT0gdHJ1ZSkgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgIGF1dG9mb2N1czogKG9wdGlvbnMuYXV0b2ZvY3VzID09PSB0cnVlKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgZXh0cmFLZXlzOiBrZXlNYXBzLFxuICAgICAgICBkaXJlY3Rpb246IG9wdGlvbnMuZGlyZWN0aW9uLFxuICAgICAgICBsaW5lV3JhcHBpbmc6IChvcHRpb25zLmxpbmVXcmFwcGluZyA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlLFxuICAgICAgICBhbGxvd0Ryb3BGaWxlVHlwZXM6IFsndGV4dC9wbGFpbiddLFxuICAgICAgICBwbGFjZWhvbGRlcjogb3B0aW9ucy5wbGFjZWhvbGRlciB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykgfHwgJycsXG4gICAgICAgIHN0eWxlU2VsZWN0ZWRUZXh0OiAob3B0aW9ucy5zdHlsZVNlbGVjdGVkVGV4dCAhPSB1bmRlZmluZWQpID8gb3B0aW9ucy5zdHlsZVNlbGVjdGVkVGV4dCA6ICFpc01vYmlsZSgpLFxuICAgICAgICBzY3JvbGxiYXJTdHlsZTogKG9wdGlvbnMuc2Nyb2xsYmFyU3R5bGUgIT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuc2Nyb2xsYmFyU3R5bGUgOiAnbmF0aXZlJyxcbiAgICAgICAgY29uZmlndXJlTW91c2U6IGNvbmZpZ3VyZU1vdXNlLFxuICAgICAgICBpbnB1dFN0eWxlOiAob3B0aW9ucy5pbnB1dFN0eWxlICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLmlucHV0U3R5bGUgOiBpc01vYmlsZSgpID8gJ2NvbnRlbnRlZGl0YWJsZScgOiAndGV4dGFyZWEnLFxuICAgICAgICBzcGVsbGNoZWNrOiAob3B0aW9ucy5uYXRpdmVTcGVsbGNoZWNrICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLm5hdGl2ZVNwZWxsY2hlY2sgOiB0cnVlLFxuICAgICAgICBhdXRvUmVmcmVzaDogKG9wdGlvbnMuYXV0b1JlZnJlc2ggIT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuYXV0b1JlZnJlc2ggOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIHRoaXMuY29kZW1pcnJvci5nZXRTY3JvbGxlckVsZW1lbnQoKS5zdHlsZS5taW5IZWlnaHQgPSBvcHRpb25zLm1pbkhlaWdodDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXhIZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5nZXRTY3JvbGxlckVsZW1lbnQoKS5zdHlsZS5oZWlnaHQgPSBvcHRpb25zLm1heEhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5mb3JjZVN5bmMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgICAgICBjbS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY20uc2F2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmd1aSA9IHt9O1xuXG4gICAgLy8gV3JhcCBDb2RlbWlycm9yIHdpdGggY29udGFpbmVyIGJlZm9yZSBjcmVhdGUgdG9vbGJhciwgZXRjLFxuICAgIC8vIHRvIHVzZSB3aXRoIHNpZGVCeVNpZGVGdWxsc2NyZWVuIG9wdGlvbi5cbiAgICB2YXIgZWFzeU1ERUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVhc3lNREVDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnRWFzeU1ERUNvbnRhaW5lcicpO1xuICAgIGVhc3lNREVDb250YWluZXIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2FwcGxpY2F0aW9uJyk7XG4gICAgdmFyIGNtV3JhcHBlciA9IHRoaXMuY29kZW1pcnJvci5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIGNtV3JhcHBlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlYXN5TURFQ29udGFpbmVyLCBjbVdyYXBwZXIpO1xuICAgIGVhc3lNREVDb250YWluZXIuYXBwZW5kQ2hpbGQoY21XcmFwcGVyKTtcblxuICAgIGlmIChvcHRpb25zLnRvb2xiYXIgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZ3VpLnRvb2xiYXIgPSB0aGlzLmNyZWF0ZVRvb2xiYXIoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RhdHVzICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmd1aS5zdGF0dXNiYXIgPSB0aGlzLmNyZWF0ZVN0YXR1c2JhcigpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hdXRvc2F2ZSAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucy5hdXRvc2F2ZS5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYXV0b3NhdmUoKTsgLy8gdXNlIHRvIGxvYWQgbG9jYWxzdG9yYWdlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fYXV0b3NhdmVfdGltZW91dCk7XG4gICAgICAgICAgICBzZWxmLl9hdXRvc2F2ZV90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdXRvc2F2ZSgpO1xuICAgICAgICAgICAgfSwgc2VsZi5vcHRpb25zLmF1dG9zYXZlLnN1Ym1pdF9kZWxheSB8fCBzZWxmLm9wdGlvbnMuYXV0b3NhdmUuZGVsYXkgfHwgMTAwMCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNIZWlnaHQobmF0dXJhbFdpZHRoLCBuYXR1cmFsSGVpZ2h0KSB7XG4gICAgICAgIHZhciBoZWlnaHQ7XG4gICAgICAgIHZhciB2aWV3cG9ydFdpZHRoID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLkNvZGVNaXJyb3Itc2l6ZXInKSkud2lkdGgucmVwbGFjZSgncHgnLCAnJyk7XG4gICAgICAgIGlmIChuYXR1cmFsV2lkdGggPCB2aWV3cG9ydFdpZHRoKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBuYXR1cmFsSGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodCA9IChuYXR1cmFsSGVpZ2h0IC8gbmF0dXJhbFdpZHRoICogMTAwKSArICclJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIHZhciBfdm0gPSB0aGlzO1xuXG5cbiAgICBmdW5jdGlvbiBhc3NpZ25JbWFnZUJsb2NrQXR0cmlidXRlcyhwYXJlbnRFbCwgaW1nKSB7XG4gICAgICAgIHBhcmVudEVsLnNldEF0dHJpYnV0ZSgnZGF0YS1pbWctc3JjJywgaW1nLnVybCk7XG4gICAgICAgIHBhcmVudEVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnLS1iZy1pbWFnZTp1cmwoJyArIGltZy51cmwgKyAnKTstLXdpZHRoOicgKyBpbWcubmF0dXJhbFdpZHRoICsgJ3B4Oy0taGVpZ2h0OicgKyBjYWxjSGVpZ2h0KGltZy5uYXR1cmFsV2lkdGgsIGltZy5uYXR1cmFsSGVpZ2h0KSk7XG4gICAgICAgIF92bS5jb2RlbWlycm9yLnNldFNpemUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVJbWFnZXMoKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5wcmV2aWV3SW1hZ2VzSW5FZGl0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhc3lNREVDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLmNtLWltYWdlLW1hcmtlcicpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRFbCA9IGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50RWwuaW5uZXJUZXh0Lm1hdGNoKC9eIVxcWy4qP1xcXVxcKC4qXFwpL2cpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaW1nIHBhc3RlZCBvbiB0aGUgc2FtZSBsaW5lIHdpdGggb3RoZXIgdGV4dCwgZG9uJ3QgcHJldmlldywgcHJldmlldyBvbmx5IGltYWdlcyBvbiBzZXBhcmF0ZSBsaW5lXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJlbnRFbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtaW1nLXNyYycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNyY0F0dHIgPSBwYXJlbnRFbC5pbm5lclRleHQubWF0Y2goJ1xcXFwoKC4qKVxcXFwpJyk7IC8vIG1pZ2h0IHJlcXVpcmUgYmV0dGVyIHBhcnNpbmcgYWNjb3JkaW5nIHRvIG1hcmtkb3duIHNwZWNcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5FTURFaW1hZ2VzQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LkVNREVpbWFnZXNDYWNoZSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzcmNBdHRyICYmIHNyY0F0dHIubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVNyYyA9IHNyY0F0dHJbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW1hZ2VzUHJldmlld0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTcmMgPSBvcHRpb25zLmltYWdlc1ByZXZpZXdIYW5kbGVyKHNyY0F0dHJbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmZW5zaXZlIGNoZWNrIG1ha2luZyBzdXJlIHRoZSBoYW5kbGVyIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIHJldHVybnMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3U3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVNyYyA9IG5ld1NyYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghd2luZG93LkVNREVpbWFnZXNDYWNoZVtrZXlTcmNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5FTURFaW1hZ2VzQ2FjaGVba2V5U3JjXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoOiBpbWcubmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXR1cmFsSGVpZ2h0OiBpbWcubmF0dXJhbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBrZXlTcmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25JbWFnZUJsb2NrQXR0cmlidXRlcyhwYXJlbnRFbCwgd2luZG93LkVNREVpbWFnZXNDYWNoZVtrZXlTcmNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0ga2V5U3JjO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduSW1hZ2VCbG9ja0F0dHJpYnV0ZXMocGFyZW50RWwsIHdpbmRvdy5FTURFaW1hZ2VzQ2FjaGVba2V5U3JjXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY29kZW1pcnJvci5vbigndXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBoYW5kbGVJbWFnZXMoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZ3VpLnNpZGVCeVNpZGUgPSB0aGlzLmNyZWF0ZVNpZGVCeVNpZGUoKTtcbiAgICB0aGlzLl9yZW5kZXJlZCA9IHRoaXMuZWxlbWVudDtcblxuICAgIGlmIChvcHRpb25zLmF1dG9mb2N1cyA9PT0gdHJ1ZSB8fCBlbC5hdXRvZm9jdXMpIHtcbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLy8gRml4ZXMgQ29kZU1pcnJvciBidWcgKCMzNDQpXG4gICAgdmFyIHRlbXBfY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRlbXBfY20ucmVmcmVzaCgpO1xuICAgIH0uYmluZCh0ZW1wX2NtKSwgMCk7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmRvY3VtZW50T25LZXlEb3duKTtcbn07XG5cbi8vIFNhZmFyaSwgaW4gUHJpdmF0ZSBCcm93c2luZyBNb2RlLCBsb29rcyBsaWtlIGl0IHN1cHBvcnRzIGxvY2FsU3RvcmFnZSBidXQgYWxsIGNhbGxzIHRvIHNldEl0ZW0gdGhyb3cgUXVvdGFFeGNlZWRlZEVycm9yLiBXZSdyZSBnb2luZyB0byBkZXRlY3QgdGhpcyBhbmQgc2V0IGEgdmFyaWFibGUgYWNjb3JkaW5nbHkuXG5mdW5jdGlvbiBpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSgpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzbWRlX2xvY2FsU3RvcmFnZScsIDEpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3NtZGVfbG9jYWxTdG9yYWdlJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuRWFzeU1ERS5wcm90b3R5cGUuYXV0b3NhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgdmFyIGVhc3lNREUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQgPT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCA9PSAnJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vhc3lNREU6IFlvdSBtdXN0IHNldCBhIHVuaXF1ZUlkIHRvIHVzZSB0aGUgYXV0b3NhdmUgZmVhdHVyZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5iaW5kZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChlYXN5TURFLmVsZW1lbnQuZm9ybSAhPSBudWxsICYmIGVhc3lNREUuZWxlbWVudC5mb3JtICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVhc3lNREUuZWxlbWVudC5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGVhc3lNREUuYXV0b3NhdmVUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICBlYXN5TURFLmF1dG9zYXZlVGltZW91dElkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzbWRlXycgKyBlYXN5TURFLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b3NhdmUuYmluZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b3NhdmUubG9hZGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzbWRlXycgKyB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQpID09ICdzdHJpbmcnICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzbWRlXycgKyB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQpICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2RlbWlycm9yLnNldFZhbHVlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzbWRlXycgKyB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQpKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b3NhdmUuZm91bmRTYXZlZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmF1dG9zYXZlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBlYXN5TURFLnZhbHVlKCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzbWRlXycgKyB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzbWRlXycgKyB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2F1dG9zYXZlZCcpO1xuICAgICAgICBpZiAoZWwgIT0gbnVsbCAmJiBlbCAhPSB1bmRlZmluZWQgJiYgZWwgIT0gJycpIHtcbiAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHZhciBkZCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFt0aGlzLm9wdGlvbnMuYXV0b3NhdmUudGltZUZvcm1hdC5sb2NhbGUsICdlbi1VUyddLCB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudGltZUZvcm1hdC5mb3JtYXQpLmZvcm1hdChkKTtcbiAgICAgICAgICAgIHZhciBzYXZlID0gdGhpcy5vcHRpb25zLmF1dG9zYXZlLnRleHQgPT0gdW5kZWZpbmVkID8gJ0F1dG9zYXZlZDogJyA6IHRoaXMub3B0aW9ucy5hdXRvc2F2ZS50ZXh0O1xuXG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBzYXZlICsgZGQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnRWFzeU1ERTogbG9jYWxTdG9yYWdlIG5vdCBhdmFpbGFibGUsIGNhbm5vdCBhdXRvc2F2ZScpO1xuICAgIH1cbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmNsZWFyQXV0b3NhdmVkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvc2F2ZSA9PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkID09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQgPT0gJycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFYXN5TURFOiBZb3UgbXVzdCBzZXQgYSB1bmlxdWVJZCB0byBjbGVhciB0aGUgYXV0b3NhdmUgdmFsdWUnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzbWRlXycgKyB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFYXN5TURFOiBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZSwgY2Fubm90IGF1dG9zYXZlJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBPcGVuIHRoZSBicm93c2UtZmlsZSB3aW5kb3cgdG8gdXBsb2FkIGFuIGltYWdlIHRvIGEgc2VydmVyLlxuICogQHBhcmFtIFtvblN1Y2Nlc3NdIHtmdW5jdGlvbn0gc2VlIEVhc3lNREUucHJvdG90eXBlLnVwbG9hZEltYWdlXG4gKiBAcGFyYW0gW29uRXJyb3JdIHtmdW5jdGlvbn0gc2VlIEVhc3lNREUucHJvdG90eXBlLnVwbG9hZEltYWdlXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLm9wZW5Ccm93c2VGaWxlV2luZG93ID0gZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaW1hZ2VJbnB1dCA9IHRoaXMuZ3VpLnRvb2xiYXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnaW1hZ2VJbnB1dCcpWzBdO1xuICAgIGltYWdlSW5wdXQuY2xpY2soKTsgLy9kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdjbGljaycpKTsgIC8vIHJlcGxhY2VkIHdpdGggY2xpY2soKSBmb3IgSUUxMSBjb21wYXRpYmlsaXR5LlxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuaW1hZ2VVcGxvYWRGdW5jdGlvbikge1xuICAgICAgICAgICAgc2VsZi51cGxvYWRJbWFnZXNVc2luZ0N1c3RvbUZ1bmN0aW9uKHNlbGYub3B0aW9ucy5pbWFnZVVwbG9hZEZ1bmN0aW9uLCBldmVudC50YXJnZXQuZmlsZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi51cGxvYWRJbWFnZXMoZXZlbnQudGFyZ2V0LmZpbGVzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIH1cblxuICAgIGltYWdlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xufTtcblxuLyoqXG4gKiBVcGxvYWQgYW4gaW1hZ2UgdG8gdGhlIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0gZmlsZSB7RmlsZX0gVGhlIGltYWdlIHRvIHVwbG9hZCwgYXMgYSBIVE1MNSBGaWxlIG9iamVjdCAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpXG4gKiBAcGFyYW0gW29uU3VjY2Vzc10ge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGltYWdlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSB1cGxvYWRlZCwgd2l0aCBvbmUgcGFyYW1ldGVyOlxuICogLSB1cmwgKHN0cmluZyk6IFRoZSBVUkwgb2YgdGhlIHVwbG9hZGVkIGltYWdlLlxuICogQHBhcmFtIFtvbkVycm9yXSB7ZnVuY3Rpb259IEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBpbWFnZSB1cGxvYWQgZmFpbHMsIHdpdGggb25lIHBhcmFtZXRlcjpcbiAqIC0gZXJyb3IgKHN0cmluZyk6IHRoZSBkZXRhaWxlZCBlcnJvciB0byBkaXNwbGF5IHRvIHRoZSB1c2VyIChiYXNlZCBvbiBtZXNzYWdlcyBmcm9tIG9wdGlvbnMuZXJyb3JNZXNzYWdlcykuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnVwbG9hZEltYWdlID0gZnVuY3Rpb24gKGZpbGUsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBvblN1Y2Nlc3MgPSBvblN1Y2Nlc3MgfHwgZnVuY3Rpb24gb25TdWNjZXNzKGltYWdlVXJsKSB7XG4gICAgICAgIGFmdGVySW1hZ2VVcGxvYWRlZChzZWxmLCBpbWFnZVVybCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9uRXJyb3JTdXAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIC8vIHNob3cgZXJyb3Igb24gc3RhdHVzIGJhciBhbmQgcmVzZXQgYWZ0ZXIgMTAwMDBtc1xuICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgZXJyb3JNZXNzYWdlKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBzZWxmLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYkluaXQpO1xuICAgICAgICB9LCAxMDAwMCk7XG5cbiAgICAgICAgLy8gcnVuIGN1c3RvbSBlcnJvciBoYW5kbGVyXG4gICAgICAgIGlmIChvbkVycm9yICYmIHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcnVuIGVycm9yIGhhbmRsZXIgZnJvbSBvcHRpb25zLCB0aGlzIGFsZXJ0cyB0aGUgbWVzc2FnZS5cbiAgICAgICAgc2VsZi5vcHRpb25zLmVycm9yQ2FsbGJhY2soZXJyb3JNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWxsRXJyb3JNZXNzYWdlKGVycm9yTWVzc2FnZSkge1xuICAgICAgICB2YXIgdW5pdHMgPSBzZWxmLm9wdGlvbnMuaW1hZ2VUZXh0cy5zaXplVW5pdHMuc3BsaXQoJywnKTtcbiAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZVxuICAgICAgICAgICAgLnJlcGxhY2UoJyNpbWFnZV9uYW1lIycsIGZpbGUubmFtZSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCcjaW1hZ2Vfc2l6ZSMnLCBodW1hbkZpbGVTaXplKGZpbGUuc2l6ZSwgdW5pdHMpKVxuICAgICAgICAgICAgLnJlcGxhY2UoJyNpbWFnZV9tYXhfc2l6ZSMnLCBodW1hbkZpbGVTaXplKHNlbGYub3B0aW9ucy5pbWFnZU1heFNpemUsIHVuaXRzKSk7XG4gICAgfVxuXG4gICAgaWYgKGZpbGUuc2l6ZSA+IHRoaXMub3B0aW9ucy5pbWFnZU1heFNpemUpIHtcbiAgICAgICAgb25FcnJvclN1cChmaWxsRXJyb3JNZXNzYWdlKHRoaXMub3B0aW9ucy5lcnJvck1lc3NhZ2VzLmZpbGVUb29MYXJnZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybURhdGEuYXBwZW5kKCdpbWFnZScsIGZpbGUpO1xuXG4gICAgLy8gaW5zZXJ0IENTUkYgYm9keSB0b2tlbiBpZiBwcm92aWRlZCBpbiBjb25maWcuXG4gICAgaWYgKHNlbGYub3B0aW9ucy5pbWFnZUNTUkZUb2tlbiAmJiAhc2VsZi5vcHRpb25zLmltYWdlQ1NSRkhlYWRlcikge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoc2VsZi5vcHRpb25zLmltYWdlQ1NSRk5hbWUsIHNlbGYub3B0aW9ucy5pbWFnZUNTUkZUb2tlbik7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0LnVwbG9hZC5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAnJyArIE1hdGgucm91bmQoKGV2ZW50LmxvYWRlZCAqIDEwMCkgLyBldmVudC50b3RhbCk7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2JQcm9ncmVzcy5yZXBsYWNlKCcjZmlsZV9uYW1lIycsIGZpbGUubmFtZSkucmVwbGFjZSgnI3Byb2dyZXNzIycsIHByb2dyZXNzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlcXVlc3Qub3BlbignUE9TVCcsIHRoaXMub3B0aW9ucy5pbWFnZVVwbG9hZEVuZHBvaW50KTtcblxuICAgIC8vIGluc2VydCBDU1JGIGhlYWRlciB0b2tlbiBpZiBwcm92aWRlZCBpbiBjb25maWcuXG4gICAgaWYgKHNlbGYub3B0aW9ucy5pbWFnZUNTUkZUb2tlbiAmJiBzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGSGVhZGVyKSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGTmFtZSwgc2VsZi5vcHRpb25zLmltYWdlQ1NSRlRva2VuKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UodGhpcy5yZXNwb25zZVRleHQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRWFzeU1ERTogVGhlIHNlcnZlciBkaWQgbm90IHJldHVybiBhIHZhbGlkIGpzb24uJyk7XG4gICAgICAgICAgICBvbkVycm9yU3VwKGZpbGxFcnJvck1lc3NhZ2Uoc2VsZi5vcHRpb25zLmVycm9yTWVzc2FnZXMuaW1wb3J0RXJyb3IpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCAmJiByZXNwb25zZSAmJiAhcmVzcG9uc2UuZXJyb3IgJiYgcmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLmZpbGVQYXRoKSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3MoKHNlbGYub3B0aW9ucy5pbWFnZVBhdGhBYnNvbHV0ZSA/ICcnIDogKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyAnLycpKSArIHJlc3BvbnNlLmRhdGEuZmlsZVBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yICYmIHJlc3BvbnNlLmVycm9yIGluIHNlbGYub3B0aW9ucy5lcnJvck1lc3NhZ2VzKSB7ICAvLyBwcmVmb3JtYXR0ZWQgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgIG9uRXJyb3JTdXAoZmlsbEVycm9yTWVzc2FnZShzZWxmLm9wdGlvbnMuZXJyb3JNZXNzYWdlc1tyZXNwb25zZS5lcnJvcl0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuZXJyb3IpIHsgIC8vIHNlcnZlciBzaWRlIGdlbmVyYXRlZCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgb25FcnJvclN1cChmaWxsRXJyb3JNZXNzYWdlKHJlc3BvbnNlLmVycm9yKSk7XG4gICAgICAgICAgICB9IGVsc2UgeyAgLy91bmtub3duIGVycm9yXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRWFzeU1ERTogUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCByZXNwb25zZSBhZnRlciB1cGxvYWRpbmcgdGhlIGltYWdlLidcbiAgICAgICAgICAgICAgICAgICAgKyB0aGlzLnN0YXR1cyArICcgKCcgKyB0aGlzLnN0YXR1c1RleHQgKyAnKScpO1xuICAgICAgICAgICAgICAgIG9uRXJyb3JTdXAoZmlsbEVycm9yTWVzc2FnZShzZWxmLm9wdGlvbnMuZXJyb3JNZXNzYWdlcy5pbXBvcnRFcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFYXN5TURFOiBBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkIHdoZW4gdHJ5aW5nIHRvIHVwbG9hZCB0aGUgaW1hZ2UuJ1xuICAgICAgICAgICAgKyBldmVudC50YXJnZXQuc3RhdHVzICsgJyAoJyArIGV2ZW50LnRhcmdldC5zdGF0dXNUZXh0ICsgJyknKTtcbiAgICAgICAgb25FcnJvclN1cChzZWxmLm9wdGlvbnMuZXJyb3JNZXNzYWdlcy5pbXBvcnRFcnJvcik7XG4gICAgfTtcblxuICAgIHJlcXVlc3Quc2VuZChmb3JtRGF0YSk7XG5cbn07XG5cbi8qKlxuICogVXBsb2FkIGFuIGltYWdlIHRvIHRoZSBzZXJ2ZXIgdXNpbmcgYSBjdXN0b20gdXBsb2FkIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBpbWFnZVVwbG9hZEZ1bmN0aW9uIHtGdW5jdGlvbn0gVGhlIGN1c3RvbSBmdW5jdGlvbiB0byB1cGxvYWQgdGhlIGltYWdlIHBhc3NlZCBpbiBvcHRpb25zXG4gKiBAcGFyYW0gZmlsZSB7RmlsZX0gVGhlIGltYWdlIHRvIHVwbG9hZCwgYXMgYSBIVE1MNSBGaWxlIG9iamVjdCAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpLlxuICovXG5FYXN5TURFLnByb3RvdHlwZS51cGxvYWRJbWFnZVVzaW5nQ3VzdG9tRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW1hZ2VVcGxvYWRGdW5jdGlvbiwgZmlsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyhpbWFnZVVybCkge1xuICAgICAgICBhZnRlckltYWdlVXBsb2FkZWQoc2VsZiwgaW1hZ2VVcmwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciBmaWxsZWRFcnJvck1lc3NhZ2UgPSBmaWxsRXJyb3JNZXNzYWdlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIC8vIHNob3cgZXJyb3Igb24gc3RhdHVzIGJhciBhbmQgcmVzZXQgYWZ0ZXIgMTAwMDBtc1xuICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgZmlsbGVkRXJyb3JNZXNzYWdlKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBzZWxmLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYkluaXQpO1xuICAgICAgICB9LCAxMDAwMCk7XG5cbiAgICAgICAgLy8gcnVuIGVycm9yIGhhbmRsZXIgZnJvbSBvcHRpb25zLCB0aGlzIGFsZXJ0cyB0aGUgbWVzc2FnZS5cbiAgICAgICAgc2VsZi5vcHRpb25zLmVycm9yQ2FsbGJhY2soZmlsbGVkRXJyb3JNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWxsRXJyb3JNZXNzYWdlKGVycm9yTWVzc2FnZSkge1xuICAgICAgICB2YXIgdW5pdHMgPSBzZWxmLm9wdGlvbnMuaW1hZ2VUZXh0cy5zaXplVW5pdHMuc3BsaXQoJywnKTtcbiAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZVxuICAgICAgICAgICAgLnJlcGxhY2UoJyNpbWFnZV9uYW1lIycsIGZpbGUubmFtZSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCcjaW1hZ2Vfc2l6ZSMnLCBodW1hbkZpbGVTaXplKGZpbGUuc2l6ZSwgdW5pdHMpKVxuICAgICAgICAgICAgLnJlcGxhY2UoJyNpbWFnZV9tYXhfc2l6ZSMnLCBodW1hbkZpbGVTaXplKHNlbGYub3B0aW9ucy5pbWFnZU1heFNpemUsIHVuaXRzKSk7XG4gICAgfVxuXG4gICAgaW1hZ2VVcGxvYWRGdW5jdGlvbi5hcHBseSh0aGlzLCBbZmlsZSwgb25TdWNjZXNzLCBvbkVycm9yXSk7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5zZXRQcmV2aWV3TWF4SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHByZXZpZXcgPSB3cmFwcGVyLm5leHRTaWJsaW5nO1xuXG4gICAgLy8gQ2FsYyBwcmV2aWV3IG1heCBoZWlnaHRcbiAgICB2YXIgcGFkZGluZ1RvcCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHdyYXBwZXIpLnBhZGRpbmdUb3ApO1xuICAgIHZhciBib3JkZXJUb3BXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHdyYXBwZXIpLmJvcmRlclRvcFdpZHRoKTtcbiAgICB2YXIgb3B0aW9uc01heEhlaWdodCA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy5tYXhIZWlnaHQpO1xuICAgIHZhciB3cmFwcGVyTWF4SGVpZ2h0ID0gb3B0aW9uc01heEhlaWdodCArIHBhZGRpbmdUb3AgKiAyICsgYm9yZGVyVG9wV2lkdGggKiAyO1xuICAgIHZhciBwcmV2aWV3TWF4SGVpZ2h0ID0gd3JhcHBlck1heEhlaWdodC50b1N0cmluZygpICsgJ3B4JztcblxuICAgIHByZXZpZXcuc3R5bGUuaGVpZ2h0ID0gcHJldmlld01heEhlaWdodDtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmNyZWF0ZVNpZGVCeVNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgcHJldmlldyA9IHdyYXBwZXIubmV4dFNpYmxpbmc7XG5cbiAgICBpZiAoIXByZXZpZXcgfHwgIXByZXZpZXcuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1zaWRlJykpIHtcbiAgICAgICAgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwcmV2aWV3LmNsYXNzTmFtZSA9ICdlZGl0b3ItcHJldmlldy1zaWRlJztcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZXZpZXdDbGFzcykge1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMucHJldmlld0NsYXNzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLnByZXZpZXdDbGFzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLnByZXZpZXdDbGFzc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucHJldmlld0NsYXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHByZXZpZXcuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMucHJldmlld0NsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocHJldmlldywgd3JhcHBlci5uZXh0U2libGluZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnNldFByZXZpZXdNYXhIZWlnaHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnN5bmNTaWRlQnlTaWRlUHJldmlld1Njcm9sbCA9PT0gZmFsc2UpIHJldHVybiBwcmV2aWV3O1xuICAgIC8vIFN5bmNzIHNjcm9sbCAgZWRpdG9yIC0+IHByZXZpZXdcbiAgICB2YXIgY1Njcm9sbCA9IGZhbHNlO1xuICAgIHZhciBwU2Nyb2xsID0gZmFsc2U7XG4gICAgY20ub24oJ3Njcm9sbCcsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmIChjU2Nyb2xsKSB7XG4gICAgICAgICAgICBjU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcFNjcm9sbCA9IHRydWU7XG4gICAgICAgIHZhciBoZWlnaHQgPSB2LmdldFNjcm9sbEluZm8oKS5oZWlnaHQgLSB2LmdldFNjcm9sbEluZm8oKS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciByYXRpbyA9IHBhcnNlRmxvYXQodi5nZXRTY3JvbGxJbmZvKCkudG9wKSAvIGhlaWdodDtcbiAgICAgICAgdmFyIG1vdmUgPSAocHJldmlldy5zY3JvbGxIZWlnaHQgLSBwcmV2aWV3LmNsaWVudEhlaWdodCkgKiByYXRpbztcbiAgICAgICAgcHJldmlldy5zY3JvbGxUb3AgPSBtb3ZlO1xuICAgIH0pO1xuXG4gICAgLy8gU3luY3Mgc2Nyb2xsICBwcmV2aWV3IC0+IGVkaXRvclxuICAgIHByZXZpZXcub25zY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwU2Nyb2xsKSB7XG4gICAgICAgICAgICBwU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY1Njcm9sbCA9IHRydWU7XG4gICAgICAgIHZhciBoZWlnaHQgPSBwcmV2aWV3LnNjcm9sbEhlaWdodCAtIHByZXZpZXcuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgcmF0aW8gPSBwYXJzZUZsb2F0KHByZXZpZXcuc2Nyb2xsVG9wKSAvIGhlaWdodDtcbiAgICAgICAgdmFyIG1vdmUgPSAoY20uZ2V0U2Nyb2xsSW5mbygpLmhlaWdodCAtIGNtLmdldFNjcm9sbEluZm8oKS5jbGllbnRIZWlnaHQpICogcmF0aW87XG4gICAgICAgIGNtLnNjcm9sbFRvKDAsIG1vdmUpO1xuICAgIH07XG4gICAgcmV0dXJuIHByZXZpZXc7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5jcmVhdGVUb29sYmFyID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgaXRlbXMgPSBpdGVtcyB8fCB0aGlzLm9wdGlvbnMudG9vbGJhcjtcblxuICAgIGlmICghaXRlbXMgfHwgaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0b29sYmFyQnVpbHRJbkJ1dHRvbnNbaXRlbXNbaV1dICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXRlbXNbaV0gPSB0b29sYmFyQnVpbHRJbkJ1dHRvbnNbaXRlbXNbaV1dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhci5jbGFzc05hbWUgPSAnZWRpdG9yLXRvb2xiYXInO1xuICAgIGJhci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbGJhcicpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHRvb2xiYXJEYXRhID0ge307XG4gICAgc2VsZi50b29sYmFyID0gaXRlbXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGl0ZW1zW2ldLm5hbWUgPT0gJ2d1aWRlJyAmJiBzZWxmLm9wdGlvbnMudG9vbGJhckd1aWRlSWNvbiA9PT0gZmFsc2UpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmhpZGVJY29ucyAmJiBzZWxmLm9wdGlvbnMuaGlkZUljb25zLmluZGV4T2YoaXRlbXNbaV0ubmFtZSkgIT0gLTEpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAvLyBGdWxsc2NyZWVuIGRvZXMgbm90IHdvcmsgd2VsbCBvbiBtb2JpbGUgZGV2aWNlcyAoZXZlbiB0YWJsZXRzKVxuICAgICAgICAvLyBJbiB0aGUgZnV0dXJlLCBob3BlZnVsbHkgdGhpcyBjYW4gYmUgcmVzb2x2ZWRcbiAgICAgICAgaWYgKChpdGVtc1tpXS5uYW1lID09ICdmdWxsc2NyZWVuJyB8fCBpdGVtc1tpXS5uYW1lID09ICdzaWRlLWJ5LXNpZGUnKSAmJiBpc01vYmlsZSgpKVxuICAgICAgICAgICAgY29udGludWU7XG5cblxuICAgICAgICAvLyBEb24ndCBpbmNsdWRlIHRyYWlsaW5nIHNlcGFyYXRvcnNcbiAgICAgICAgaWYgKGl0ZW1zW2ldID09PSAnfCcpIHtcbiAgICAgICAgICAgIHZhciBub25TZXBhcmF0b3JJY29uc0ZvbGxvdyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gKGkgKyAxKTsgeCA8IGl0ZW1zLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zW3hdICE9PSAnfCcgJiYgKCFzZWxmLm9wdGlvbnMuaGlkZUljb25zIHx8IHNlbGYub3B0aW9ucy5oaWRlSWNvbnMuaW5kZXhPZihpdGVtc1t4XS5uYW1lKSA9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uU2VwYXJhdG9ySWNvbnNGb2xsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFub25TZXBhcmF0b3JJY29uc0ZvbGxvdylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBpY29uIGFuZCBhcHBlbmQgdG8gdGhlIHRvb2xiYXJcbiAgICAgICAgKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgZWw7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gJ3wnKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBjcmVhdGVTZXAoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGVsID0gY3JlYXRlVG9vbGJhckRyb3Bkb3duKGl0ZW0sIHNlbGYub3B0aW9ucy50b29sYmFyVGlwcywgc2VsZi5vcHRpb25zLnNob3J0Y3V0cywgc2VsZik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gY3JlYXRlVG9vbGJhckJ1dHRvbihpdGVtLCB0cnVlLCBzZWxmLm9wdGlvbnMudG9vbGJhclRpcHMsIHNlbGYub3B0aW9ucy5zaG9ydGN1dHMsICdidXR0b24nLCBzZWxmKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0b29sYmFyRGF0YVtpdGVtLm5hbWUgfHwgaXRlbV0gPSBlbDtcbiAgICAgICAgICAgIGJhci5hcHBlbmRDaGlsZChlbCk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgaW5wdXQgZWxlbWVudCAoaWUuIDxpbnB1dCB0eXBlPSdmaWxlJz4pLCB1c2VkIGFtb25nXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSAnaW1wb3J0LWltYWdlJyBpY29uIHRvIG9wZW4gdGhlIGJyb3dzZS1maWxlIHdpbmRvdy5cbiAgICAgICAgICAgIGlmIChpdGVtLm5hbWUgPT09ICd1cGxvYWQtaW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIGltYWdlSW5wdXQuY2xhc3NOYW1lID0gJ2ltYWdlSW5wdXQnO1xuICAgICAgICAgICAgICAgIGltYWdlSW5wdXQudHlwZSA9ICdmaWxlJztcbiAgICAgICAgICAgICAgICBpbWFnZUlucHV0Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbWFnZUlucHV0Lm5hbWUgPSAnaW1hZ2UnO1xuICAgICAgICAgICAgICAgIGltYWdlSW5wdXQuYWNjZXB0ID0gc2VsZi5vcHRpb25zLmltYWdlQWNjZXB0O1xuICAgICAgICAgICAgICAgIGltYWdlSW5wdXQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBpbWFnZUlucHV0LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgICAgIGJhci5hcHBlbmRDaGlsZChpbWFnZUlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoaXRlbXNbaV0pO1xuICAgIH1cblxuICAgIHNlbGYudG9vbGJhcl9kaXYgPSBiYXI7XG4gICAgc2VsZi50b29sYmFyRWxlbWVudHMgPSB0b29sYmFyRGF0YTtcblxuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICBjbS5vbignY3Vyc29yQWN0aXZpdHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ID0gZ2V0U3RhdGUoY20pO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0b29sYmFyRGF0YSkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSB0b29sYmFyRGF0YVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgIT0gJ2Z1bGxzY3JlZW4nICYmIGtleSAhPSAnc2lkZS1ieS1zaWRlJykge1xuICAgICAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KShrZXkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgY21XcmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICBjbVdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYmFyLCBjbVdyYXBwZXIpO1xuICAgIHJldHVybiBiYXI7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5jcmVhdGVTdGF0dXNiYXIgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgLy8gSW5pdGlhbGl6ZVxuICAgIHN0YXR1cyA9IHN0YXR1cyB8fCB0aGlzLm9wdGlvbnMuc3RhdHVzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgc3RhdHVzIHZhcmlhYmxlIGlzIHZhbGlkXG4gICAgaWYgKCFzdGF0dXMgfHwgc3RhdHVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2V0IHVwIHRoZSBidWlsdC1pbiBpdGVtc1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBpLCBvblVwZGF0ZSwgb25BY3Rpdml0eSwgZGVmYXVsdFZhbHVlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXR1cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBSZXNldCBzb21lIHZhbHVlc1xuICAgICAgICBvblVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgb25BY3Rpdml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkO1xuXG5cbiAgICAgICAgLy8gSGFuZGxlIGlmIGN1c3RvbSBvciBub3RcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0dXNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHN0YXR1c1tpXS5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzdGF0dXNbaV0uZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgIG9uVXBkYXRlOiBzdGF0dXNbaV0ub25VcGRhdGUsXG4gICAgICAgICAgICAgICAgb25BY3Rpdml0eTogc3RhdHVzW2ldLm9uQWN0aXZpdHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gc3RhdHVzW2ldO1xuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3dvcmRzJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSB3b3JkQ291bnQoY20uZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvblVwZGF0ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSB3b3JkQ291bnQoY20uZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2xpbmVzJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBjbS5saW5lQ291bnQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9uVXBkYXRlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IGNtLmxpbmVDb3VudCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjdXJzb3InKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9ICcxOjEnO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb25BY3Rpdml0eSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NMaW5lID0gcG9zLmxpbmUgKyAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zQ29sdW1uID0gcG9zLmNoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gcG9zTGluZSArICc6JyArIHBvc0NvbHVtbjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnYXV0b3NhdmUnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmF1dG9zYXZlICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zLmF1dG9zYXZlLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnaWQnLCAnYXV0b3NhdmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndXBsb2FkLWltYWdlJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBvcHRpb25zLmltYWdlVGV4dHMuc2JJbml0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvblVwZGF0ZTogb25VcGRhdGUsXG4gICAgICAgICAgICAgICAgb25BY3Rpdml0eTogb25BY3Rpdml0eSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBDcmVhdGUgZWxlbWVudCBmb3IgdGhlIHN0YXR1cyBiYXJcbiAgICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFyLmNsYXNzTmFtZSA9ICdlZGl0b3Itc3RhdHVzYmFyJztcblxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IHNwYW4gZm9yIGVhY2ggaXRlbVxuICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBTdG9yZSBpbiB0ZW1wb3JhcnkgdmFyaWFibGVcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcblxuXG4gICAgICAgIC8vIENyZWF0ZSBzcGFuIGVsZW1lbnRcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBpdGVtLmNsYXNzTmFtZTtcblxuXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZGVmYXVsdFZhbHVlIGlzIGEgZnVuY3Rpb25cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaXRlbS5kZWZhdWx0VmFsdWUoZWwpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBFbnN1cmUgdGhlIG9uVXBkYXRlIGlzIGEgZnVuY3Rpb25cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtLm9uVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjbG9zdXJlIGFyb3VuZCB0aGUgc3BhbiBvZiB0aGUgY3VycmVudCBhY3Rpb24sIHRoZW4gZXhlY3V0ZSB0aGUgb25VcGRhdGUgaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5jb2RlbWlycm9yLm9uKCd1cGRhdGUnLCAoZnVuY3Rpb24gKGVsLCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5vblVwZGF0ZShlbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oZWwsIGl0ZW0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtLm9uQWN0aXZpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNsb3N1cmUgYXJvdW5kIHRoZSBzcGFuIG9mIHRoZSBjdXJyZW50IGFjdGlvbiwgdGhlbiBleGVjdXRlIHRoZSBvbkFjdGl2aXR5IGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuY29kZW1pcnJvci5vbignY3Vyc29yQWN0aXZpdHknLCAoZnVuY3Rpb24gKGVsLCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5vbkFjdGl2aXR5KGVsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfShlbCwgaXRlbSkpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gQXBwZW5kIHRoZSBpdGVtIHRvIHRoZSBzdGF0dXMgYmFyXG4gICAgICAgIGJhci5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuXG5cbiAgICAvLyBJbnNlcnQgdGhlIHN0YXR1cyBiYXIgaW50byB0aGUgRE9NXG4gICAgdmFyIGNtV3JhcHBlciA9IHRoaXMuY29kZW1pcnJvci5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIGNtV3JhcHBlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiYXIsIGNtV3JhcHBlci5uZXh0U2libGluZyk7XG4gICAgcmV0dXJuIGJhcjtcbn07XG5cbi8qKlxuICogR2V0IG9yIHNldCB0aGUgdGV4dCBjb250ZW50LlxuICovXG5FYXN5TURFLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjbS5nZXRWYWx1ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNtLmdldERvYygpLnNldFZhbHVlKHZhbCk7XG4gICAgICAgIGlmICh0aGlzLmlzUHJldmlld0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgICAgICAgICB2YXIgcHJldmlldyA9IHdyYXBwZXIubGFzdENoaWxkO1xuICAgICAgICAgICAgdmFyIHByZXZpZXdfcmVzdWx0ID0gdGhpcy5vcHRpb25zLnByZXZpZXdSZW5kZXIodmFsLCBwcmV2aWV3KTtcbiAgICAgICAgICAgIGlmIChwcmV2aWV3X3Jlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZXZpZXcuaW5uZXJIVE1MID0gcHJldmlld19yZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5cbi8qKlxuICogQmluZCBzdGF0aWMgbWV0aG9kcyBmb3IgZXhwb3J0cy5cbiAqL1xuRWFzeU1ERS50b2dnbGVCb2xkID0gdG9nZ2xlQm9sZDtcbkVhc3lNREUudG9nZ2xlSXRhbGljID0gdG9nZ2xlSXRhbGljO1xuRWFzeU1ERS50b2dnbGVTdHJpa2V0aHJvdWdoID0gdG9nZ2xlU3RyaWtldGhyb3VnaDtcbkVhc3lNREUudG9nZ2xlQmxvY2txdW90ZSA9IHRvZ2dsZUJsb2NrcXVvdGU7XG5FYXN5TURFLnRvZ2dsZUhlYWRpbmdTbWFsbGVyID0gdG9nZ2xlSGVhZGluZ1NtYWxsZXI7XG5FYXN5TURFLnRvZ2dsZUhlYWRpbmdCaWdnZXIgPSB0b2dnbGVIZWFkaW5nQmlnZ2VyO1xuRWFzeU1ERS50b2dnbGVIZWFkaW5nMSA9IHRvZ2dsZUhlYWRpbmcxO1xuRWFzeU1ERS50b2dnbGVIZWFkaW5nMiA9IHRvZ2dsZUhlYWRpbmcyO1xuRWFzeU1ERS50b2dnbGVIZWFkaW5nMyA9IHRvZ2dsZUhlYWRpbmczO1xuRWFzeU1ERS50b2dnbGVIZWFkaW5nNCA9IHRvZ2dsZUhlYWRpbmc0O1xuRWFzeU1ERS50b2dnbGVIZWFkaW5nNSA9IHRvZ2dsZUhlYWRpbmc1O1xuRWFzeU1ERS50b2dnbGVIZWFkaW5nNiA9IHRvZ2dsZUhlYWRpbmc2O1xuRWFzeU1ERS50b2dnbGVDb2RlQmxvY2sgPSB0b2dnbGVDb2RlQmxvY2s7XG5FYXN5TURFLnRvZ2dsZVVub3JkZXJlZExpc3QgPSB0b2dnbGVVbm9yZGVyZWRMaXN0O1xuRWFzeU1ERS50b2dnbGVPcmRlcmVkTGlzdCA9IHRvZ2dsZU9yZGVyZWRMaXN0O1xuRWFzeU1ERS5jbGVhbkJsb2NrID0gY2xlYW5CbG9jaztcbkVhc3lNREUuZHJhd0xpbmsgPSBkcmF3TGluaztcbkVhc3lNREUuZHJhd0ltYWdlID0gZHJhd0ltYWdlO1xuRWFzeU1ERS5kcmF3VXBsb2FkZWRJbWFnZSA9IGRyYXdVcGxvYWRlZEltYWdlO1xuRWFzeU1ERS5kcmF3VGFibGUgPSBkcmF3VGFibGU7XG5FYXN5TURFLmRyYXdIb3Jpem9udGFsUnVsZSA9IGRyYXdIb3Jpem9udGFsUnVsZTtcbkVhc3lNREUudW5kbyA9IHVuZG87XG5FYXN5TURFLnJlZG8gPSByZWRvO1xuRWFzeU1ERS50b2dnbGVQcmV2aWV3ID0gdG9nZ2xlUHJldmlldztcbkVhc3lNREUudG9nZ2xlU2lkZUJ5U2lkZSA9IHRvZ2dsZVNpZGVCeVNpZGU7XG5FYXN5TURFLnRvZ2dsZUZ1bGxTY3JlZW4gPSB0b2dnbGVGdWxsU2NyZWVuO1xuXG4vKipcbiAqIEJpbmQgaW5zdGFuY2UgbWV0aG9kcyBmb3IgZXhwb3J0cy5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlQm9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVCb2xkKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUl0YWxpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVJdGFsaWModGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlU3RyaWtldGhyb3VnaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVTdHJpa2V0aHJvdWdoKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUJsb2NrcXVvdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlQmxvY2txdW90ZSh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVIZWFkaW5nU21hbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVIZWFkaW5nU21hbGxlcih0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVIZWFkaW5nQmlnZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmdCaWdnZXIodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSGVhZGluZzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSGVhZGluZzEodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSGVhZGluZzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSGVhZGluZzIodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSGVhZGluZzMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSGVhZGluZzModGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSGVhZGluZzQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSGVhZGluZzQodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSGVhZGluZzUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSGVhZGluZzUodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSGVhZGluZzYgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSGVhZGluZzYodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlQ29kZUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUNvZGVCbG9jayh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVVbm9yZGVyZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZVVub3JkZXJlZExpc3QodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlT3JkZXJlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlT3JkZXJlZExpc3QodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUuY2xlYW5CbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhbkJsb2NrKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLmRyYXdMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgIGRyYXdMaW5rKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLmRyYXdJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkcmF3SW1hZ2UodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUuZHJhd1VwbG9hZGVkSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZHJhd1VwbG9hZGVkSW1hZ2UodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUuZHJhd1RhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGRyYXdUYWJsZSh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS5kcmF3SG9yaXpvbnRhbFJ1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZHJhd0hvcml6b250YWxSdWxlKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgdW5kbyh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24gKCkge1xuICAgIHJlZG8odGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlUHJldmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVQcmV2aWV3KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZVNpZGVCeVNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlU2lkZUJ5U2lkZSh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVGdWxsU2NyZWVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUZ1bGxTY3JlZW4odGhpcyk7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5pc1ByZXZpZXdBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgcHJldmlldyA9IHdyYXBwZXIubGFzdENoaWxkO1xuXG4gICAgcmV0dXJuIHByZXZpZXcuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKTtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmlzU2lkZUJ5U2lkZUFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIHZhciBwcmV2aWV3ID0gd3JhcHBlci5uZXh0U2libGluZztcblxuICAgIHJldHVybiBwcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlLXNpZGUnKTtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmlzRnVsbHNjcmVlbkFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG5cbiAgICByZXR1cm4gY20uZ2V0T3B0aW9uKCdmdWxsU2NyZWVuJyk7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG5cbiAgICByZXR1cm4gZ2V0U3RhdGUoY20pO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUudG9UZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIHZhciBlYXN5TURFQ29udGFpbmVyID0gd3JhcHBlci5wYXJlbnROb2RlO1xuXG4gICAgaWYgKGVhc3lNREVDb250YWluZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3VpLnRvb2xiYXIpIHtcbiAgICAgICAgICAgIGVhc3lNREVDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5ndWkudG9vbGJhcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3VpLnN0YXR1c2Jhcikge1xuICAgICAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmd1aS5zdGF0dXNiYXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmd1aS5zaWRlQnlTaWRlKSB7XG4gICAgICAgICAgICBlYXN5TURFQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZ3VpLnNpZGVCeVNpZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVW53cmFwIGVhc3lNREVjb250YWluZXIgYmVmb3JlIGNvZGVtaXJyb3IgdG9UZXh0QXJlYSgpIGNhbGxcbiAgICBlYXN5TURFQ29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIGVhc3lNREVDb250YWluZXIpO1xuICAgIGVhc3lNREVDb250YWluZXIucmVtb3ZlKCk7XG5cbiAgICBjbS50b1RleHRBcmVhKCk7XG5cbiAgICBpZiAodGhpcy5hdXRvc2F2ZVRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvc2F2ZVRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuYXV0b3NhdmVUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2xlYXJBdXRvc2F2ZWRWYWx1ZSgpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRWFzeU1ERTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/easymde/src/js/easymde.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/easymde/dist/easymde.min.css":
/*!***************************************************!*\
  !*** ./node_modules/easymde/dist/easymde.min.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"17bd888c94c1\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9kaXN0L2Vhc3ltZGUubWluLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL2Vhc3ltZGUvZGlzdC9lYXN5bWRlLm1pbi5jc3M/NDE5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjE3YmQ4ODhjOTRjMVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/easymde/dist/easymde.min.css\n");

/***/ })

};
;